  /// \file DQMMonitorElementView.cc
/*
 *
 * DQMMonitorElementView.cc source template automatically generated by a class generator
 * Creation date : lun. oct. 12 2015
 *
 * This file is part of DQM4HEP libraries.
 *
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 *
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 *
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "dqm4hep/vis/DQMMonitorElementView.h"
#include "dqm4hep/vis/DQMMonitoring.h"
#include "dqm4hep/vis/DQMMonitoringController.h"
#include "dqm4hep/vis/DQMMonitoringView.h"
#include "dqm4hep/vis/DQMMonitoringModel.h"
#include "dqm4hep/vis/DQMCanvasView.h"
#include "dqm4hep/vis/DQMGuiMonitorElement.h"
#include "dqm4hep/vis/DQMGuiMonitorElementClient.h"
#include "dqm4hep/DQMMonitorElement.h"
#include "dqm4hep/DQMLogging.h"
#include "dqm4hep/DQMArchiver.h"
#include "dqm4hep/DQMStorage.h"
#include "dqm4hep/DQMDirectory.h"

#include <QVBoxLayout>
#include <QMenu>
#include <QKeyEvent>
#include <QSet>
#include <QCommonStyle>
#include <QTimer>
#include <QApplication>
#include <QFileDialog>

#include "TFile.h"
#include "TDirectory.h"

namespace dqm4hep
{

class TreeWidgetItem : public QTreeWidgetItem
{
public:
	/** Constructor
	 */
	TreeWidgetItem();

	/** Constructor with parent item
	 */
	TreeWidgetItem(QTreeWidgetItem *pParent);

	/** Constructor with tree widget
	 */
	TreeWidgetItem(QTreeWidget *pTreeWidget);

	/** Set data for a target column with a given role
	 */
	void setData(int column, int role, const QVariant & value);

	/** Set whether the element can be checked (subscribed)
	 */
	void setCheckable(bool checkable);

private:
	bool            m_checkable;
};

//-------------------------------------------------------------------------------------------------

TreeWidgetItem::TreeWidgetItem() :
		QTreeWidgetItem(),
		m_checkable(true)
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

TreeWidgetItem::TreeWidgetItem(QTreeWidgetItem *pParent) :
		QTreeWidgetItem(pParent),
		m_checkable(true)
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

TreeWidgetItem::TreeWidgetItem(QTreeWidget *pTreeWidget) :
		QTreeWidgetItem(pTreeWidget),
		m_checkable(true)
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

void TreeWidgetItem::setData(int column, int role, const QVariant & value)
{
	if(0 == column && role == Qt::CheckStateRole)
	{
		Qt::CheckState oldState = static_cast<Qt::CheckState>(this->data(column, role).toInt());
		Qt::CheckState newState = static_cast<Qt::CheckState>(value.toInt());

		if(oldState == newState)
		{
			QTreeWidgetItem::setData(column, role, value);
			return;
		}

		DQMMonitorElementNavigator *pNavigator = qobject_cast<DQMMonitorElementNavigator *>(this->treeWidget());

		if(!pNavigator)
		{
			QTreeWidgetItem::setData(column, role, value);
			return;
		}

		if(!pNavigator->isMonitorElementItem(this))
		{
			QTreeWidgetItem::setData(column, role, value);
			return;
		}

		QString collectorName(pNavigator->getCollectorName());
		QString moduleName(pNavigator->getModuleName(this));
		QString fullPathName(pNavigator->getFullPathName(this));
		QString monitorElementName(this->text(0));
		std::string fullName = (DQMPath(fullPathName.toStdString()) + monitorElementName.toStdString()).getPath();


		DQMMonitorElementRequest request;
		request.insert(DQMMonitorElementRequest::value_type(moduleName.toStdString(), fullName));

		if(Qt::Checked == newState)
		{
			if(m_checkable)
			{
				pNavigator->getMonitoring()->getController()->subscribe(collectorName.toStdString(), request);
			}
			else
			{
				pNavigator->getMonitoring()->getController()->log(ERROR, "Can't subscribe to monitor element to " + fullName + " (disabled)");
				return;
			}
		}
		else
		{
			pNavigator->getMonitoring()->getController()->unsubscribe(collectorName.toStdString(), request);
		}
	}

	QTreeWidgetItem::setData(column, role, value);
}

//-------------------------------------------------------------------------------------------------

void TreeWidgetItem::setCheckable(bool checkable)
{
	m_checkable = checkable;
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

DQMMonitorElementNavigator::DQMMonitorElementNavigator(const QString &collectorName, DQMMonitoring *pMonitoring, QWidget *pParent) :
		m_collectorName(collectorName),
		QTreeWidget(pParent),
		m_pMonitoring(pMonitoring),
		m_subscriptionEnabled(true)
{
	setHeaderLabel("Monitor elements");

	setContextMenuPolicy(Qt::CustomContextMenu);
	setSelectionMode(QAbstractItemView::ExtendedSelection);
	setSelectionBehavior(QAbstractItemView::SelectRows);

	setFocusPolicy(Qt::StrongFocus);

	connect(this, SIGNAL(customContextMenuRequested(const QPoint &)),
			this, SLOT(showContextMenu(const QPoint &)));

    connect(this, SIGNAL(itemDoubleClicked(QTreeWidgetItem *, int)),
            this, SLOT(handleItemDoubleClick(QTreeWidgetItem *, int)));

    connect(this, SIGNAL(itemExpanded(QTreeWidgetItem *)),
    		this, SLOT(handleItemExpanded(QTreeWidgetItem *)));

    connect(this, SIGNAL(itemCollapsed(QTreeWidgetItem *)),
    		this, SLOT(handleItemCollapsed(QTreeWidgetItem *)));
}

//-------------------------------------------------------------------------------------------------

DQMMonitorElementNavigator::~DQMMonitorElementNavigator()
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

DQMMonitoring *DQMMonitorElementNavigator::getMonitoring() const
{
	return m_pMonitoring;
}

//-------------------------------------------------------------------------------------------------

const QString &DQMMonitorElementNavigator::getCollectorName() const
{
	return m_collectorName;
}

//-------------------------------------------------------------------------------------------------

QStringList DQMMonitorElementNavigator::getModuleNames() const
{
	QStringList moduleNameList;

	for(int i=0 ; i<topLevelItemCount() ; i++)
		moduleNameList << this->topLevelItem(i)->text(0);

	return moduleNameList;
}

//-------------------------------------------------------------------------------------------------

QTreeWidgetItem *DQMMonitorElementNavigator::mkdir(const QString &moduleName)
{
	for(int i=0 ; i<topLevelItemCount() ; i++)
	{
		if(moduleName == this->topLevelItem(i)->text(0))
			return topLevelItem(i);
	}

	QTreeWidgetItem *pModuleDirectoryItem = new TreeWidgetItem(this);

	QCommonStyle style;
	pModuleDirectoryItem->setText(0, moduleName);
	pModuleDirectoryItem->setData(0, Qt::UserRole, static_cast<int>(DIRECTORY_ITEM));
	pModuleDirectoryItem->setIcon(0, style.standardIcon(QStyle::SP_DirOpenIcon));
	this->addTopLevelItem(pModuleDirectoryItem);

	return pModuleDirectoryItem;
}

//-------------------------------------------------------------------------------------------------

QTreeWidgetItem *DQMMonitorElementNavigator::mkdir(const QString &moduleName, const QString &fullPathDirName)
{
	QTreeWidgetItem *pModuleDirectoryItem = mkdir(moduleName);

	std::vector<std::string> tokens;
	DQM4HEP::tokenize(fullPathDirName.toStdString(), tokens, "/");

	QTreeWidgetItem *pCurrentParentItem = pModuleDirectoryItem;

	for(unsigned int i=0 ; i<tokens.size() ; i++)
	{
		QString dirName = tokens.at(i).c_str();
		pCurrentParentItem = this->mkdir(pCurrentParentItem, dirName);
	}

	return pCurrentParentItem;
}

//-------------------------------------------------------------------------------------------------

bool DQMMonitorElementNavigator::rmdir(const QString &moduleName)
{
	if(!this->dirExists(moduleName))
		return false;

	QTreeWidgetItem *pModuleDirectoryItem = this->mkdir(moduleName);

	// clear the directory
	this->clear(pModuleDirectoryItem);

	// and remove it from the tree
	delete this->takeTopLevelItem(this->indexOfTopLevelItem(pModuleDirectoryItem));

	return true;
}

//-------------------------------------------------------------------------------------------------

bool DQMMonitorElementNavigator::rmdir(const QString &moduleName, const QString &fullPathDirName)
{
	if(!this->dirExists(moduleName, fullPathDirName))
		return false;

	QTreeWidgetItem *pDirectoryItem = this->mkdir(moduleName, fullPathDirName);
	QTreeWidgetItem *pParentWidget = pDirectoryItem->parent();

	// clear the directory
	this->clear(pDirectoryItem);

	// and remove it from its parent
	pParentWidget->removeChild(pDirectoryItem);
	delete pDirectoryItem;

	return true;
}

//-------------------------------------------------------------------------------------------------

bool DQMMonitorElementNavigator::dirExists(const QString &moduleName)
{
	QTreeWidgetItem *pModuleDirectoryItem = NULL;

	for(int i=0 ; i<topLevelItemCount() ; i++)
	{
		if(moduleName == this->topLevelItem(i)->text(0))
		{
			pModuleDirectoryItem = this->topLevelItem(i);
			break;
		}
	}

	return (NULL != pModuleDirectoryItem);
}

//-------------------------------------------------------------------------------------------------

bool DQMMonitorElementNavigator::dirExists(const QString &moduleName, const QString &fullPathDirName)
{
	QTreeWidgetItem *pModuleDirectoryItem = NULL;

	for(int i=0 ; i<topLevelItemCount() ; i++)
	{
		if(moduleName == this->topLevelItem(i)->text(0))
		{
			pModuleDirectoryItem = this->topLevelItem(i);
			break;
		}
	}

	if(NULL == pModuleDirectoryItem)
		return false;

	std::string path = fullPathDirName.toStdString();
	std::vector<std::string> tokens;
	DQM4HEP::tokenize(path, tokens, "/");

	QTreeWidgetItem *pCurrentDirectory = pModuleDirectoryItem;

	for(unsigned int i=0 ; i<tokens.size() ; i++)
	{
		if(this->dirExists(pCurrentDirectory, tokens.at(i).c_str()))
			pCurrentDirectory = this->mkdir(pCurrentDirectory, tokens.at(i).c_str());
		else
			return false;
	}

	return true;
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementNavigator::clear()
{
	while(this->topLevelItemCount() != 0)
	{
		QTreeWidgetItem *pTopLevelItem = this->topLevelItem(0);

		this->clear(pTopLevelItem);

		delete this->takeTopLevelItem(0);
	}
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementNavigator::updateMonitorElement(DQMGuiMonitorElement *pMonitorElement)
{
	QString moduleName = pMonitorElement->getMonitorElement()->getModuleName().c_str();
	QString fullPath = pMonitorElement->getMonitorElement()->getPath().getPath().c_str();
	QString name = pMonitorElement->getMonitorElement()->getName().c_str();
	DQMQuality quality = pMonitorElement->getMonitorElement()->getQuality();

	QTreeWidgetItem *pDirectoryItem = this->mkdir(moduleName, fullPath);
	QTreeWidgetItem *pMonitorElementItem = this->addMonitorElement(pDirectoryItem, name);

	QIcon qualityIcon = this->getMonitoring()->getController()->getIcon(quality);
	pMonitorElementItem->setIcon(0, qualityIcon);
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementNavigator::updateMonitorElements(const DQMGuiMonitorElementList &monitorElementList)
{
	for(unsigned int i=0 ; i<monitorElementList.size() ; i++)
		this->updateMonitorElement(monitorElementList.at(i));
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementNavigator::removeMonitorElement(DQMGuiMonitorElement *pMonitorElement)
{
	QString moduleName = pMonitorElement->getMonitorElement()->getModuleName().c_str();
	QString fullPath = pMonitorElement->getMonitorElement()->getPath().getPath().c_str();
	QString name = pMonitorElement->getMonitorElement()->getName().c_str();

	if(this->dirExists(moduleName, fullPath))
	{
		QTreeWidgetItem *pTreeItem = this->mkdir(moduleName, fullPath);

		for(int i=0 ; i<pTreeItem->childCount() ; i++)
		{
			if(name == pTreeItem->child(i)->text(0) && this->isMonitorElementItem(pTreeItem->child(i)))
			{
				QTreeWidgetItem *pMonitorElementItem = pTreeItem->child(i);
				pTreeItem->removeChild(pMonitorElementItem);
				delete pMonitorElementItem;

				return;
			}
		}
	}
}

//-------------------------------------------------------------------------------------------------

QString DQMMonitorElementNavigator::getFullPathName(QTreeWidgetItem *pTreeItem) const
{
	if(!pTreeItem)
		return QString();

	//   "/mod/dir1/dir2"
	//   "/"
	//   "/mod"

	QString fullPathName;
	QTreeWidgetItem *pCurrentItem = pTreeItem;

	// do not put the me name in the full path
	if(this->isMonitorElementItem(pTreeItem))
		pCurrentItem = pCurrentItem->parent();

	while(1)
	{
		bool isTopLevelItem = (pCurrentItem->parent() == 0);

		if(isTopLevelItem)
			break;

		fullPathName = pCurrentItem->text(0) + "/" + fullPathName;
		pCurrentItem = pCurrentItem->parent();
	}

	fullPathName = "/" + fullPathName;

	return fullPathName;
}

//-------------------------------------------------------------------------------------------------

QString DQMMonitorElementNavigator::getModuleName(QTreeWidgetItem *pTreeItem) const
{
	if(!pTreeItem)
		return QString();

	QTreeWidgetItem *pCurrentItem = pTreeItem;

	while(1)
	{
		pCurrentItem = pCurrentItem->parent();

		bool isTopLevelItem = (pCurrentItem->parent() == 0);

		if(isTopLevelItem)
			break;
	}

	return pCurrentItem->text(0);
}

//-------------------------------------------------------------------------------------------------

bool DQMMonitorElementNavigator::isDirectoryItem(QTreeWidgetItem *pTreeItem) const
{
	return (pTreeItem->data(0, Qt::UserRole).toInt() == DIRECTORY_ITEM);
}

//-------------------------------------------------------------------------------------------------

bool DQMMonitorElementNavigator::isMonitorElementItem(QTreeWidgetItem *pTreeItem) const
{
	return (pTreeItem->data(0, Qt::UserRole).toInt() == MONITOR_ELEMENT_ITEM);
}

//-------------------------------------------------------------------------------------------------

QList<QTreeWidgetItem*> DQMMonitorElementNavigator::getSelectedMonitorElementItems() const
{
	QList<QTreeWidgetItem*> selectedItems = this->selectedItems();
	QList<QTreeWidgetItem*> selectedMonitorElementItems;

	for(int i=0 ; i<selectedItems.count() ; i++)
	{
		if(this->isMonitorElementItem(selectedItems.at(i)))
			selectedMonitorElementItems.append(selectedItems.at(i));
	}

	return selectedMonitorElementItems;
}

//-------------------------------------------------------------------------------------------------

QList<QTreeWidgetItem*> DQMMonitorElementNavigator::getSelectedDirectoryItems() const
{
	QList<QTreeWidgetItem*> selectedItems = this->selectedItems();
	QList<QTreeWidgetItem*> selectedDirectoryItems;

	for(int i=0 ; i<selectedItems.count() ; i++)
	{
		if(this->isDirectoryItem(selectedItems.at(i)))
			selectedDirectoryItems.append(selectedItems.at(i));
	}

	return selectedDirectoryItems;
}

//-------------------------------------------------------------------------------------------------

QList<QTreeWidgetItem*> DQMMonitorElementNavigator::getCheckedMonitorElements() const
{
	QList<QTreeWidgetItem*> checkedMonitorElements;

	for(int i=0 ; i<topLevelItemCount() ; i++)
	{
		QTreeWidgetItem *pModuleItem = topLevelItem(i);
		this->getRecursiveMonitorElements(pModuleItem, checkedMonitorElements, true);
	}

	return checkedMonitorElements;
}

//-------------------------------------------------------------------------------------------------

QList<QTreeWidgetItem*> DQMMonitorElementNavigator::getCheckedMonitorElements(const QString &moduleName) const
{
	QList<QTreeWidgetItem*> checkedMonitorElements;

	for(int i=0 ; i<topLevelItemCount() ; i++)
	{
		if(this->topLevelItem(i)->text(0) == moduleName)
		{
			this->getRecursiveMonitorElements(this->topLevelItem(i), checkedMonitorElements, true);
			break;
		}
	}

	return checkedMonitorElements;
}

//-------------------------------------------------------------------------------------------------

QList<QTreeWidgetItem*> DQMMonitorElementNavigator::getAllMonitorElementItems(const QString &moduleName) const
{
	QList<QTreeWidgetItem*> monitorElementItems;

	for(int i=0 ; i<topLevelItemCount() ; i++)
	{
		if(this->topLevelItem(i)->text(0) == moduleName)
		{
			this->getRecursiveMonitorElements(this->topLevelItem(i), monitorElementItems, false);
			break;
		}
	}

	return monitorElementItems;
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementNavigator::enableSubscription(bool enable)
{
	if(m_subscriptionEnabled == enable)
		return;

	m_subscriptionEnabled = enable;

	for(int i=0 ; i<topLevelItemCount() ; i++)
	{
		QList<QTreeWidgetItem*> monitorElementItems;
		this->getRecursiveMonitorElements(this->topLevelItem(i), monitorElementItems, false);

		for(int j=0 ; j<monitorElementItems.size() ; j++)
		{
			TreeWidgetItem *pMonitorElementItem = dynamic_cast<TreeWidgetItem *>(monitorElementItems.at(j));
			pMonitorElementItem->setCheckable( m_subscriptionEnabled );
		}
	}
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementNavigator::checkAllMonitorElements()
{
	for(int i=0 ; i<topLevelItemCount() ; i++)
	{
		QTreeWidgetItem *pModuleItem = topLevelItem(i);

		QList<QTreeWidgetItem*> uncheckedMonitorElements;
		this->getRecursiveMonitorElements(pModuleItem, uncheckedMonitorElements, false);

		for(int j=0 ; j<uncheckedMonitorElements.count() ; j++)
			uncheckedMonitorElements.at(j)->setCheckState(0, Qt::Checked);
	}
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementNavigator::uncheckAllMonitorElements()
{
	for(int i=0 ; i<topLevelItemCount() ; i++)
	{
		QTreeWidgetItem *pModuleItem = topLevelItem(i);

		QList<QTreeWidgetItem*> checkedMonitorElements;
		this->getRecursiveMonitorElements(pModuleItem, checkedMonitorElements, false);

		for(int j=0 ; j<checkedMonitorElements.count() ; j++)
			checkedMonitorElements.at(j)->setCheckState(0, Qt::Unchecked);
	}
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementNavigator::checkSelectedMonitorElements()
{
	// Handle selected items instead of only the current item
	QList<QTreeWidgetItem *> selectedItems = this->selectedItems();
	QSet<QTreeWidgetItem *> monitorElementItems;

	// first, get all monitor elements
	for(int i = 0; i < selectedItems.count(); i++)
	{
		QTreeWidgetItem *pTreeWidgetItem = selectedItems.at(i);

		if(this->isDirectoryItem(pTreeWidgetItem))
		{
			QList<QTreeWidgetItem *> monitorElementItemList;
			this->getRecursiveMonitorElements(pTreeWidgetItem, monitorElementItemList, false);
			monitorElementItems += QSet<QTreeWidgetItem *>::fromList(monitorElementItemList);
		}
		else
			monitorElementItems << pTreeWidgetItem;
	}

	QSet<QTreeWidgetItem*>::iterator iter = monitorElementItems.begin();

	while(iter != monitorElementItems.end())
	{
		QTreeWidgetItem *pTreeWidgetItem = *iter;
		pTreeWidgetItem->setCheckState(0, Qt::Checked);
		++iter;
	}
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementNavigator::uncheckSelectedMonitorElements()
{
	// Handle selected items instead of only the current item
	QList<QTreeWidgetItem *> selectedItems = this->selectedItems();
	QSet<QTreeWidgetItem *> monitorElementItems;

	// first, get all monitor elements
	for(int i = 0; i < selectedItems.count(); i++)
	{
		QTreeWidgetItem *pTreeWidgetItem = selectedItems.at(i);

		if(this->isDirectoryItem(pTreeWidgetItem))
		{
			QList<QTreeWidgetItem *> monitorElementItemList;
			this->getRecursiveMonitorElements(pTreeWidgetItem, monitorElementItemList, false);
			monitorElementItems += QSet<QTreeWidgetItem *>::fromList(monitorElementItemList);
		}
		else
			monitorElementItems << pTreeWidgetItem;
	}

	QSet<QTreeWidgetItem*>::iterator iter = monitorElementItems.begin();

	while(iter != monitorElementItems.end())
	{
		QTreeWidgetItem *pTreeWidgetItem = *iter;
		pTreeWidgetItem->setCheckState(0, Qt::Unchecked);
		++iter;
	}
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementNavigator::removeSelectedItems()
{
	// Handle selected items instead of only the current item
	QList<QTreeWidgetItem *> selectedItems = this->selectedItems();

	if( selectedItems.size() != 1 )
		return;

	QTreeWidgetItem *pTreeWidgetItem = selectedItems.at(0);
	QSet<QTreeWidgetItem *> monitorElementItems;
	bool isDirectory = false;

	if( this->isMonitorElementItem( pTreeWidgetItem ) )
	{
		monitorElementItems << pTreeWidgetItem;
		std::cout << "Item is element" << std::endl;
	}
	else if( this->isDirectoryItem(pTreeWidgetItem) )
	{
		QList<QTreeWidgetItem *> monitorElementItemList;
		this->getRecursiveMonitorElements(pTreeWidgetItem, monitorElementItemList, false);
		monitorElementItems += QSet<QTreeWidgetItem *>::fromList(monitorElementItemList);
		std::cout << "Item is dir" << std::endl;
		isDirectory = true;
	}

	QSet<QTreeWidgetItem*>::iterator iter = monitorElementItems.begin();

	while(iter != monitorElementItems.end())
	{
		QTreeWidgetItem *pTreeWidgetItem = *iter;

		// unsubscribe to element before to remove it
		pTreeWidgetItem->setCheckState(0, Qt::Unchecked);

		QString collectorName(this->getCollectorName());
		QString moduleName(this->getModuleName(pTreeWidgetItem));
		QString fullPathName(this->getFullPathName(pTreeWidgetItem));
		QString monitorElementName(pTreeWidgetItem->text(0));

		// removed it before removing the element in the model
		if( pTreeWidgetItem->parent() )
			pTreeWidgetItem->parent()->removeChild(pTreeWidgetItem);

		delete pTreeWidgetItem;

		this->getMonitoring()->getModel()->removeMonitorElement(
				collectorName.toStdString(),
				moduleName.toStdString(),
				fullPathName.toStdString(),
				monitorElementName.toStdString() );

		++iter;
	}

	if( isDirectory )
	{
		// remove child elements
		this->clear( pTreeWidgetItem );

		if( pTreeWidgetItem->parent() )
		{
			pTreeWidgetItem->parent()->removeChild(pTreeWidgetItem);
			delete pTreeWidgetItem;
		}
		else
			delete this->takeTopLevelItem(this->indexOfTopLevelItem(pTreeWidgetItem));
	}
}

//-------------------------------------------------------------------------------------------------

QTreeWidgetItem *DQMMonitorElementNavigator::mkdir(QTreeWidgetItem *pTreeItem, const QString &dirName)
{
	for(int i=0 ; i<pTreeItem->childCount() ; i++)
	{
		if(dirName == pTreeItem->child(i)->text(0) && this->isDirectoryItem(pTreeItem->child(i)))
			return pTreeItem->child(i);
	}

	QTreeWidgetItem *pDirectoryItem = new TreeWidgetItem(pTreeItem);

	QCommonStyle style;
	pDirectoryItem->setText(0, dirName);
	pDirectoryItem->setData(0, Qt::UserRole, static_cast<int>(DIRECTORY_ITEM));
	pDirectoryItem->setIcon(0, style.standardIcon(QStyle::SP_DirOpenIcon));
	pTreeItem->addChild(pDirectoryItem);

	return pDirectoryItem;
}

//-------------------------------------------------------------------------------------------------

QTreeWidgetItem *DQMMonitorElementNavigator::addMonitorElement(QTreeWidgetItem *pTreeItem, const QString &name)
{
	if(!this->isDirectoryItem(pTreeItem))
		return 0;

	for(int i=0 ; i<pTreeItem->childCount() ; i++)
	{
		if(name == pTreeItem->child(i)->text(0) && this->isMonitorElementItem(pTreeItem->child(i)))
			return pTreeItem->child(i);
	}

	TreeWidgetItem *pMonitorElementItem = new TreeWidgetItem(pTreeItem);
	pMonitorElementItem->setText(0, name);
	pMonitorElementItem->setData(0, Qt::UserRole, static_cast<int>(MONITOR_ELEMENT_ITEM));
	pMonitorElementItem->setCheckState(0, Qt::Unchecked);
	pMonitorElementItem->setCheckable( m_subscriptionEnabled );
	pTreeItem->addChild(pMonitorElementItem);

	return pMonitorElementItem;
}

//-------------------------------------------------------------------------------------------------

bool DQMMonitorElementNavigator::dirExists(QTreeWidgetItem *pTreeItem, const QString &name) const
{
	for(int i=0 ; i<pTreeItem->childCount() ; i++)
	{
		if(name == pTreeItem->child(i)->text(0) && this->isMonitorElementItem(pTreeItem->child(i)))
			return true;
	}

	return false;
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementNavigator::clear(QTreeWidgetItem *pTreeItem) const
{
	while(pTreeItem->childCount() != 0)
	{
		QTreeWidgetItem *pChildItem = pTreeItem->child(0);

		this->clear(pChildItem);

		pTreeItem->removeChild(0);
		delete pChildItem;
	}
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementNavigator::getRecursiveMonitorElements(QTreeWidgetItem *pTreeItem, QList<QTreeWidgetItem*> &monitorElementItems, bool onlyChecked) const
{
	for(int i=0 ; i<pTreeItem->childCount() ; i++)
	{
		if(this->isMonitorElementItem(pTreeItem->child(i)))
		{
			if(onlyChecked && pTreeItem->child(i)->checkState(0) != Qt::Checked)
				continue;

			monitorElementItems.append(pTreeItem->child(i));
		}
		else if(this->isDirectoryItem(pTreeItem->child(i)))
		{
			this->getRecursiveMonitorElements(pTreeItem->child(i), monitorElementItems, onlyChecked);
		}
	}
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementNavigator::exportAll()
{
	this->exportToRootFile(false);
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementNavigator::exportChecked()
{
	this->exportToRootFile(true);
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementNavigator::exportToRootFile(bool onlyChecked)
{
    QString fileName = QFileDialog::getSaveFileName(this->getMonitoring()->getView()->getMainWindow(), tr("Export to ROOT file"),
                    QString(""),
                    "ROOT files (*.root)");

    if(fileName.isEmpty())
    	return;

    TFile *pFile = TFile::Open(fileName.toStdString().c_str(), "RECREATE");

	for(int i=0 ; i<topLevelItemCount() ; i++)
	{
		QTreeWidgetItem *pModuleItem = topLevelItem(i);
		QString moduleName(pModuleItem->text(0));

		QList<QTreeWidgetItem*> monitorElements;
		this->getRecursiveMonitorElements(pModuleItem, monitorElements, onlyChecked);

		TDirectory *pModuleDirectory = pFile->mkdir( moduleName.toStdString().c_str() );

		if( ! pModuleDirectory )
			continue;

		// fill the storage
		DQMStorage storage;

		for(int i = 0; i < monitorElements.count(); i++)
		{
			QTreeWidgetItem *pMonitorElementItem = monitorElements.at(i);

			QString collectorName(this->getCollectorName());
			QString moduleName(this->getModuleName(pMonitorElementItem));
			QString fullPathName(this->getFullPathName(pMonitorElementItem));
			QString monitorElementName(pMonitorElementItem->text(0));

			DQMGuiMonitorElement *pMonitorElement =
					this->getMonitoring()->getModel()->findMonitorElement(
							collectorName.toStdString(),
							moduleName.toStdString(),
							fullPathName.toStdString(),
							monitorElementName.toStdString());

			if( ! pMonitorElement)
				continue;

			storage.addMonitorElement( pMonitorElement->getMonitorElement() );
		}

		DQMArchiver::recursiveFill(storage.getRootDirectory(), pModuleDirectory);
	}

	pFile->cd();
	pFile->Write();
	pFile->Close();
	delete pFile;
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementNavigator::showContextMenu(const QPoint &point)
{
    QPoint globalPos = this->mapToGlobal(point);

    QMenu contextMenu;

    QMenu *pExportToRootMenu = contextMenu.addMenu("Export to ROOT File");
    QAction *pExportAllAction = pExportToRootMenu->addAction("Export all", this, SLOT(exportAll()));
    QAction *pExportCheckedAction = pExportToRootMenu->addAction("Export checked", this, SLOT(exportChecked()));
    contextMenu.addSeparator();

    QAction *pUpdateAction = contextMenu.addAction("Update", this, SLOT(queryUpdate()));
    contextMenu.addSeparator();

    QMenu *pDrawInTabMenu = contextMenu.addMenu("Draw in ...");
    QAction *pDrawInTabAction = 0;
    QList<QAction *> drawInTabActionList;

    DQMCanvasView *pCanvasView = this->getMonitoring()->getView()->getCanvasView();
    int currentIndex = pCanvasView->getCanvasAreaIndex(pCanvasView->getCurrentCanvasArea());

    QAction *pDrawInNewTabAction = pDrawInTabMenu->addAction("New area", this, SLOT(drawSelectedMonitorElements()));
    pDrawInNewTabAction->setData(-1);
    pDrawInTabMenu->addSeparator();

    pDrawInTabAction = pDrawInTabMenu->addAction((pCanvasView->getCanvasAreaName(currentIndex) + " (current)").c_str(), this, SLOT(drawSelectedMonitorElements()));
    pDrawInTabAction->setData(currentIndex);
    drawInTabActionList << pDrawInTabAction;

    for(int i=0 ; i<pCanvasView->canvasAreaCount() ; i++)
    {
        if(i == currentIndex)
            continue;

        pDrawInTabAction = pDrawInTabMenu->addAction(pCanvasView->getCanvasAreaName(i).c_str(), this, SLOT(drawSelectedMonitorElements()));
        pDrawInTabAction->setData(i);
        drawInTabActionList << pDrawInTabAction;
    }

    QAction *pShowInfoAction = contextMenu.addAction("Show info", this, SLOT(openSelectedMonitorElementInfo()));
    QAction *pRemoveAction = contextMenu.addAction("Remove", this, SLOT(removeSelectedItems()));
    contextMenu.addSeparator();

    QList<QTreeWidgetItem *> selectedItems = this->selectedItems();
    QTreeWidgetItem *pSelectedItem = 0;

    if( selectedItems.size() == 1 )
    {
    	pSelectedItem = selectedItems.at(0);

    	if( ! this->isMonitorElementItem( pSelectedItem ) )
    		pShowInfoAction->setEnabled( false );
    }
    else
    {
    	pRemoveAction->setEnabled(false);
    }

    QAction *pCheckAllAction = contextMenu.addAction("Subscribe all", this, SLOT(checkAllMonitorElements()));
    QAction *pCheckSelectedAction = contextMenu.addAction("Subscribe selected", this, SLOT(checkSelectedMonitorElements()));
    contextMenu.addSeparator();

    QAction *pUncheckAllAction = contextMenu.addAction("Un-subscribe all", this, SLOT(uncheckAllMonitorElements()));
    QAction *pUncheckSelectedAction = contextMenu.addAction("Un-subscribe selected", this, SLOT(uncheckSelectedMonitorElements()));

    // process context menu
    contextMenu.exec(globalPos);
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementNavigator::drawSelectedMonitorElements()
{
	DQMCanvasView *pCanvasView = this->getMonitoring()->getView()->getCanvasView();
	int areaIndex = -1 ;

	// If slot triggered by an action get the areaIndex from its data
	if (QAction *pAction = qobject_cast<QAction*>(sender()))
		areaIndex = pAction->data().toInt();
	// Otherwise take the current areaIndex (slot executed by either double click or returnKey)
	else
		areaIndex = pCanvasView->getCanvasAreaIndex(pCanvasView->getCurrentCanvasArea());

	QList<QTreeWidgetItem*> selectedMonitorElements = this->selectedItems();

	if(areaIndex < 0)
	{
		pCanvasView->createCanvasAreaAndSetCurrent();
		areaIndex = pCanvasView->canvasAreaCount()-1;
	}

	if(areaIndex > pCanvasView->canvasAreaCount()-1)
	{
		this->getMonitoring()->getController()->log(ERROR, QString("Canvas area not found ! (index = %1)").arg(areaIndex).toStdString());
		return;
	}

	int nDrawElements = 0;

	// Handle selected items instead of only the current item
	QSet<QTreeWidgetItem *> monitorElementSet;

	for(int i=0 ; i<selectedMonitorElements.count() ; i++)
	{
		QTreeWidgetItem *pMonitorElementItem = selectedMonitorElements.at(i);

		if (this->isDirectoryItem(pMonitorElementItem))
		{
			QList<QTreeWidgetItem *> monitorElementItemList;
			this->getRecursiveMonitorElements(pMonitorElementItem, monitorElementItemList, false);
			monitorElementSet += QSet<QTreeWidgetItem *>::fromList(monitorElementItemList);
		}
		else
			monitorElementSet << pMonitorElementItem;
	}

	for ( auto iter = monitorElementSet.begin(), endIter = monitorElementSet.end(); iter != endIter; ++iter)
	{
		QTreeWidgetItem *pMonitorElementItem = *iter;

		QString collectorName(this->getCollectorName());
		QString moduleName(this->getModuleName(pMonitorElementItem));
		QString fullPathName(this->getFullPathName(pMonitorElementItem));
		QString monitorElementName(pMonitorElementItem->text(0));

		DQMGuiMonitorElement *pMonitorElement =
				this->getMonitoring()->getModel()->findMonitorElement(
						collectorName.toStdString(),
						moduleName.toStdString(),
						fullPathName.toStdString(),
						monitorElementName.toStdString());

		if(!pMonitorElement)
			continue;

		pCanvasView->drawInArea(pMonitorElement, areaIndex);
		pMonitorElementItem->setCheckState(0, Qt::Checked);
		this->setFocus(Qt::OtherFocusReason);

		nDrawElements++;
	}

	if(nDrawElements == selectedMonitorElements.count())
	{
		this->getMonitoring()->getController()->log(MESSAGE, QString("Number of drawn monitor elements : %1").arg(nDrawElements).toStdString());
	}
	else if(nDrawElements < selectedMonitorElements.count() && nDrawElements != 0)
	{
		this->getMonitoring()->getController()->log(WARNING, QString("Monitor elements drawn (%1 success, %2 failed)").arg(nDrawElements).arg(selectedMonitorElements.count()-nDrawElements).toStdString());
	}
	else
	{
		this->getMonitoring()->getController()->log(ERROR, QString("No monitor elements drawn ! (%1 requested)").arg(selectedMonitorElements.count()).toStdString());
	}
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementNavigator::handleItemDoubleClick(QTreeWidgetItem *pTreeWidgetItem, int column)
{
	if(!this->isMonitorElementItem(pTreeWidgetItem))
		return;

	this->drawSelectedMonitorElements();
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementNavigator::keyPressEvent( QKeyEvent * pKeyEvent )
{
    if(pKeyEvent->key() == Qt::Key_Space || pKeyEvent->key() == Qt::Key_Return )
			this->drawSelectedMonitorElements();
		else
      return QTreeView::keyPressEvent(pKeyEvent);
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementNavigator::mousePressEvent(QMouseEvent *pMouseEvent)
{
	if (pMouseEvent->button() == Qt::LeftButton
			&& pMouseEvent->type() == QEvent::MouseButtonPress)
	{
		// find me item at this position
		QPoint point(pMouseEvent->pos());
		QTreeWidgetItem *pItem = this->itemAt(point);

		// if no item, then process at least the mousePressEvent of the super class
		if(!pItem)
		{
			QTreeView::mousePressEvent(pMouseEvent);
			return;
		}

		QList<QTreeWidgetItem *> selectedItems;

		// if the clicked item is selected, get all the selection
		// to drag and drop in a canvas area
		if(pItem->isSelected())
			selectedItems = this->selectedItems();
		// else just use the clicked item (maybe a directory)
		else
			selectedItems << pItem;

		// clear and rebuild the drag item list
		QSet<QTreeWidgetItem *> monitorElementItems;
		m_dragItemList.clear();

		// first, get all monitor elements
		for(int i = 0; i < selectedItems.count(); i++)
		{
			QTreeWidgetItem *pTreeWidgetItem = selectedItems.at(i);

			if(this->isDirectoryItem(pTreeWidgetItem))
			{
				QList<QTreeWidgetItem *> monitorElementItemList;
				this->getRecursiveMonitorElements(pTreeWidgetItem, monitorElementItemList, false);
				monitorElementItems += QSet<QTreeWidgetItem *>::fromList(monitorElementItemList);
			}
			else
				monitorElementItems << pTreeWidgetItem;
		}

		m_dragItemList = monitorElementItems.toList();

		// trigger the drag action only if ths list is not empty.
		// the drag action start after the double click interval
		// startDrag() check is the left mouse button is still
		// pressed at this time.
		// this is needed to differentiate a double click and a simple click
		// for the drag and process
		if(!m_dragItemList.isEmpty())
			QTimer::singleShot(QApplication::doubleClickInterval(), this, SLOT(startDrag()));
	}

	QTreeView::mousePressEvent(pMouseEvent);
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementNavigator::handleItemExpanded(QTreeWidgetItem *pTreeWidgetItem)
{
	if(this->isDirectoryItem(pTreeWidgetItem))
	{
		QCommonStyle style;
		pTreeWidgetItem->setIcon(0, style.standardIcon(QStyle::SP_DirOpenIcon));
	}
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementNavigator::handleItemCollapsed(QTreeWidgetItem * pTreeWidgetItem)
{
	if(this->isDirectoryItem(pTreeWidgetItem))
	{
		QCommonStyle style;
		pTreeWidgetItem->setIcon(0, style.standardIcon(QStyle::SP_DirClosedIcon));
	}
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementNavigator::startDrag()
{
	if(QApplication::mouseButtons().testFlag(Qt::LeftButton)
	&& !m_dragItemList.isEmpty())
	{
		// serialize the item list in a byte array
		QByteArray byteArray;
		QDataStream dataStream(&byteArray, QIODevice::WriteOnly);

		QList<QTreeWidgetItem*>::iterator iter = m_dragItemList.begin();

		dataStream << qint32(m_dragItemList.count());

		while(iter != m_dragItemList.end())
		{
			QTreeWidgetItem *pTreeWidgetItem = *iter;

			QString collectorName(this->getCollectorName());
			QString moduleName(this->getModuleName(pTreeWidgetItem));
			QString fullPathName(this->getFullPathName(pTreeWidgetItem));
			QString monitorElementName(pTreeWidgetItem->text(0));

			dataStream << collectorName << moduleName << fullPathName << monitorElementName;

			++iter;
		}

		QDrag *pDrag = new QDrag(this);

		// embed the serialized items in a QMimeData
		QMimeData *pMimeData = new QMimeData();
		pMimeData->setData("dqm4hep/me-item-list", byteArray);
		pDrag->setMimeData(pMimeData);

		// process the drag and drop
		Qt::DropAction dropAction = pDrag->exec(Qt::CopyAction);

		// successful ?
		if(dropAction == Qt::CopyAction)
		{
			// check all elements
			QList<QTreeWidgetItem*>::iterator iter = m_dragItemList.begin();

			while(iter != m_dragItemList.end())
			{
				(*iter)->setCheckState(0, Qt::Checked);
				++iter;
			}
		}
		else
			this->getMonitoring()->getController()->log(ERROR, QString("No monitor elements drawn ! (%1 requested)").arg(m_dragItemList.count()).toStdString());

	}
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementNavigator::queryUpdate()
{
	QSet<QTreeWidgetItem*> selectedItems = QSet<QTreeWidgetItem*>::fromList(this->getSelectedMonitorElementItems());
	DQMGuiMonitorElementList monitorElementList;

	QString collectorName(this->getCollectorName());

	for(QSet<QTreeWidgetItem*>::iterator iter = selectedItems.begin(), endIter = selectedItems.end() ;
			endIter != iter ; ++iter)
	{
		QTreeWidgetItem *pTreeWidgetItem = *iter;


		QString moduleName(this->getModuleName(pTreeWidgetItem));
		QString fullPathName(this->getFullPathName(pTreeWidgetItem));
		QString monitorElementName(pTreeWidgetItem->text(0));

		DQMGuiMonitorElement *pMonitorElement =
				this->getMonitoring()->getModel()->findMonitorElement(
						collectorName.toStdString(),
						moduleName.toStdString(),
						fullPathName.toStdString(),
						monitorElementName.toStdString());

		if(NULL == pMonitorElement)
			continue;

		monitorElementList.push_back(pMonitorElement);
	}

	this->getMonitoring()->getController()->queryUpdate(monitorElementList);
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementNavigator::openSelectedMonitorElementInfo()
{
	QList<QTreeWidgetItem *> selectedItems = this->selectedItems();

	if( selectedItems.size() != 1 )
		return;

	QTreeWidgetItem *pTreeWidgetItem = selectedItems.at(0);

	QString collectorName(this->getCollectorName());
	QString moduleName(this->getModuleName(pTreeWidgetItem));
	QString fullPathName(this->getFullPathName(pTreeWidgetItem));
	QString monitorElementName(pTreeWidgetItem->text(0));

	DQMGuiMonitorElement *pMonitorElement =
			this->getMonitoring()->getModel()->findMonitorElement(
					collectorName.toStdString(),
					moduleName.toStdString(),
					fullPathName.toStdString(),
					monitorElementName.toStdString());

	if( pMonitorElement )
		this->getMonitoring()->getController()->openMonitorElementInfo(pMonitorElement);
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

DQMMonitorElementView::DQMMonitorElementView(DQMMonitoring *pMonitoring) :
		m_pMonitoring(pMonitoring)
{
	setLayout(new QVBoxLayout());

	m_pToolBox = new QToolBox();
	layout()->addWidget(m_pToolBox);
}

//-------------------------------------------------------------------------------------------------

DQMMonitorElementView::~DQMMonitorElementView()
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

DQMMonitoring *DQMMonitorElementView::getMonitoring() const
{
	return m_pMonitoring;
}

//-------------------------------------------------------------------------------------------------

QStringList DQMMonitorElementView::getCollectorNames() const
{
	QStringList collectorNames;

	for(int i=0 ; i<m_pToolBox->count() ; i++)
		collectorNames << m_pToolBox->itemText(i);

	return collectorNames;
}

//-------------------------------------------------------------------------------------------------

QList<QTreeWidgetItem*> DQMMonitorElementView::getCheckedMonitorElements() const
{
	QList<QTreeWidgetItem*> checkedMonitorElements;

	for(int i=0 ; i<m_pToolBox->count() ; i++)
	{
		DQMMonitorElementNavigator *pNavigator = qobject_cast<DQMMonitorElementNavigator*>(m_pToolBox->widget(i));
		checkedMonitorElements.append(pNavigator->getCheckedMonitorElements());
	}

	return checkedMonitorElements;
}

//-------------------------------------------------------------------------------------------------

QList<QTreeWidgetItem*> DQMMonitorElementView::getCheckedMonitorElements(const std::string &collectorName) const
{
	QList<QTreeWidgetItem*> checkedMonitorElements;
	DQMMonitorElementNavigator *pNavigator = NULL;

	for(int i=0 ; i<m_pToolBox->count() ; i++)
	{
		if(m_pToolBox->itemText(i).toStdString() == collectorName)
		{
			pNavigator = qobject_cast<DQMMonitorElementNavigator*>(m_pToolBox->widget(i));
			break;
		}
	}

	if(NULL == pNavigator)
		return checkedMonitorElements;

	return pNavigator->getCheckedMonitorElements();
}

//-------------------------------------------------------------------------------------------------

QList<QTreeWidgetItem*> DQMMonitorElementView::getCheckedMonitorElements(const std::string &collectorName, const std::string &moduleName) const
{
	DQMMonitorElementNavigator *pNavigator = NULL;

	for(int i=0 ; i<m_pToolBox->count() ; i++)
	{
		if(m_pToolBox->itemText(i).toStdString() == collectorName)
		{
			pNavigator = qobject_cast<DQMMonitorElementNavigator*>(m_pToolBox->widget(i));
			break;
		}
	}

	if(NULL == pNavigator)
		return QList<QTreeWidgetItem*>();

	return pNavigator->getCheckedMonitorElements(moduleName.c_str());
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementView::uncheckAllMonitorElements(const std::string &collectorName)
{
	for(int i=0 ; i<m_pToolBox->count() ; i++)
	{
		if(m_pToolBox->itemText(i).toStdString() == collectorName)
		{
			DQMMonitorElementNavigator *pNavigator = qobject_cast<DQMMonitorElementNavigator*>(m_pToolBox->widget(i));
			pNavigator->uncheckAllMonitorElements();
			break;
		}
	}
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementView::enableSubscription(const std::string &collectorName, bool enable)
{
	for(int i=0 ; i<m_pToolBox->count() ; i++)
	{
		if(m_pToolBox->itemText(i).toStdString() == collectorName)
		{
			DQMMonitorElementNavigator *pNavigator = qobject_cast<DQMMonitorElementNavigator*>(m_pToolBox->widget(i));
			pNavigator->enableSubscription(enable);
			break;
		}
	}
}

//-------------------------------------------------------------------------------------------------

TiXmlElement *DQMMonitorElementView::toXml() const
{
	TiXmlElement *pXmlElement = new TiXmlElement("meView");

	// loop over collectors
	for(int c=0 ; c<m_pToolBox->count() ; c++)
	{
		TiXmlElement *pCollectorElement = new TiXmlElement("collector");
		pXmlElement->LinkEndChild(pCollectorElement);

		std::string collectorName = m_pToolBox->itemText(c).toStdString();
		pCollectorElement->SetAttribute("name", collectorName);

		DQMMonitorElementNavigator *pNavigator = qobject_cast<DQMMonitorElementNavigator*>(m_pToolBox->widget(c));

		QStringList moduleNames = pNavigator->getModuleNames();

		for(int m=0 ; m<moduleNames.count() ; m++)
		{
			QString moduleName(moduleNames.at(m));

			TiXmlElement *pModuleElement = new TiXmlElement("module");
			pCollectorElement->LinkEndChild(pModuleElement);

			pModuleElement->SetAttribute("name", moduleName.toStdString());

			QList<QTreeWidgetItem*> monitorElementItems = pNavigator->getAllMonitorElementItems(moduleName);

			for(int i=0 ; i<monitorElementItems.count() ; i++)
			{
				QTreeWidgetItem *pMonitorElementItem = monitorElementItems.at(i);

				QString fullPath(pNavigator->getFullPathName(pMonitorElementItem));
				QString name(pMonitorElementItem->text(0));
				bool checked(pMonitorElementItem->checkState(0) == Qt::Checked);

				TiXmlElement *pItemElement = new TiXmlElement("item");
				pModuleElement->LinkEndChild(pItemElement);

				pItemElement->SetAttribute("path", fullPath.toStdString());
				pItemElement->SetAttribute("name", name.toStdString());
				pItemElement->SetAttribute("checked", checked);
			}
		}
	}

	return pXmlElement;
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementView::fromXml(TiXmlElement *const pXmlElement)
{
	if(!pXmlElement)
		return;

	this->clear();

    TiXmlHandle elementHandle(pXmlElement);

    for (TiXmlElement *pCollectorElement = elementHandle.FirstChild("collector").Element(); NULL != pCollectorElement;
    		pCollectorElement = pCollectorElement->NextSiblingElement("collector"))
    {
    	std::string collectorName;
        if(pCollectorElement->QueryStringAttribute("name", &collectorName))
            continue;

        DQMMonitorElementNavigator *pNavigator = new DQMMonitorElementNavigator(collectorName.c_str(), this->getMonitoring());
		m_pToolBox->addItem(pNavigator, collectorName.c_str());

        TiXmlHandle collectorHandle(pCollectorElement);

        for (TiXmlElement *pModuleElement = collectorHandle.FirstChild("module").Element(); NULL != pModuleElement;
        		pModuleElement = pModuleElement->NextSiblingElement("module"))
        {
        	std::string moduleName;
            if(pModuleElement->QueryStringAttribute("name", &moduleName))
                continue;

            QTreeWidgetItem *pModuleItem = pNavigator->mkdir(moduleName.c_str());

            TiXmlHandle moduleHandle(pModuleElement);

            for (TiXmlElement *pItemElement = moduleHandle.FirstChild("item").Element(); NULL != pItemElement;
            		pItemElement = pItemElement->NextSiblingElement("item"))
            {
            	std::string name;
                if(pItemElement->QueryStringAttribute("name", &name))
                    continue;

            	std::string path;
                if(pItemElement->QueryStringAttribute("path", &path))
                    continue;

            	bool checked = false;
                if(pItemElement->QueryValueAttribute("checked", &checked))
                    continue;

                QTreeWidgetItem *pDirectoryItem = pNavigator->mkdir(moduleName.c_str(), path.c_str());
                QTreeWidgetItem *pMonitorElementItem = pNavigator->addMonitorElement(pDirectoryItem, name.c_str());

                if(pMonitorElementItem)
                	pMonitorElementItem->setCheckState(0, checked ? Qt::Checked : Qt::Unchecked);
            }
        }
    }
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementView::addMonitorElement(DQMGuiMonitorElement *pMonitorElement)
{
	this->updateMonitorElement(pMonitorElement);
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementView::removeMonitorElement(DQMGuiMonitorElement *pMonitorElement)
{
	QString collectorName = pMonitorElement->getMonitorElement()->getCollectorName().c_str();

	DQMMonitorElementNavigator *pNavigator = NULL;

	for(int i=0 ; i<m_pToolBox->count() ; i++)
	{
		if(m_pToolBox->itemText(i) == collectorName)
		{
			pNavigator = qobject_cast<DQMMonitorElementNavigator*>(m_pToolBox->widget(i));
			break;
		}
	}

	if(NULL == pNavigator)
		return;

	pNavigator->removeMonitorElement(pMonitorElement);
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementView::updateMonitorElement(DQMGuiMonitorElement *pMonitorElement)
{
	QString collectorName = pMonitorElement->getMonitorElement()->getCollectorName().c_str();

	DQMMonitorElementNavigator *pNavigator = NULL;

	for(int i=0 ; i<m_pToolBox->count() ; i++)
	{
		if(m_pToolBox->itemText(i) == collectorName)
		{
			pNavigator = qobject_cast<DQMMonitorElementNavigator*>(m_pToolBox->widget(i));
			break;
		}
	}

	if(NULL == pNavigator)
	{
		pNavigator = new DQMMonitorElementNavigator(collectorName, this->getMonitoring());
		m_pToolBox->addItem(pNavigator, collectorName);
	}

	pNavigator->updateMonitorElement(pMonitorElement);
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementView::replaceMonitorElement(DQMGuiMonitorElement */*pOldMonitorElement*/, DQMGuiMonitorElement *pNewMonitorElement)
{
	this->updateMonitorElement(pNewMonitorElement);
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementView::clear()
{
	for(int i=0 ; i<m_pToolBox->count() ; i++)
	{
		DQMMonitorElementNavigator *pNavigator = qobject_cast<DQMMonitorElementNavigator*>(m_pToolBox->widget(i));
		pNavigator->clear();
		m_pToolBox->removeItem(i);
		pNavigator->deleteLater();
	}
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementView::clear(const std::string &collectorName)
{
	for(int i=0 ; i<m_pToolBox->count() ; i++)
	{
		if(m_pToolBox->itemText(i) == QString(collectorName.c_str()))
		{
			DQMMonitorElementNavigator *pNavigator = qobject_cast<DQMMonitorElementNavigator*>(m_pToolBox->widget(i));
			pNavigator->clear();
			break;
		}
	}
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementView::handleMonitorElementUpdate()
{
	DQMGuiMonitorElement *pGuiMonitorElement = qobject_cast<DQMGuiMonitorElement*>(sender());
	this->updateMonitorElement(pGuiMonitorElement);
}

//-------------------------------------------------------------------------------------------------

void DQMMonitorElementView::handleMonitorElementDeletion()
{
	DQMGuiMonitorElement *pGuiMonitorElement = qobject_cast<DQMGuiMonitorElement*>(sender());
	this->removeMonitorElement(pGuiMonitorElement);

}

}

