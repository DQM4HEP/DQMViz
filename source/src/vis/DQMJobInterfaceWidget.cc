/// \file DQMJobInterfaceWidget.cc
/*
 *
 * DQMJobInterfaceWidget.cc source template automatically generated by a class generator
 * Creation date : lun. aoï¿½t 24 2015
 *
 * This file is part of DQM4HEP libraries.
 *
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 *
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 *
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */

// -- dqm4hep headers
#include "dqm4hep/vis/DQMJobInterfaceWidget.h"
#include "dqm4hep/vis/DQMJobInterface.h"
#include "DQMVizConfig.h"

// -- qt headers
#include <QMenu>
#include <QMenuBar>
#include <QAction>
#include <QWidget>
#include <QApplication>
#include <QSplitter>
#include <QMessageBox>
#include <QFileDialog>
#include <QTextEdit>
#include <QTextStream>
#include <QDebug>
#include <QInputDialog>
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QFormLayout>
#include <QGroupBox>
#include <QHeaderView>
#include <QContextMenuEvent>
#include <QShortcut>

// -- libssh headers
// #include <fcntl.h>

namespace dqm4hep
{

DQMJobInterfaceWidget::DQMJobInterfaceWidget(QWidget *pParent):
    QWidget(pParent),
    m_pAutomaticModeButton(0)
{
    m_pJobInterface = new DQMJobInterface();

    QLayout *pMainLayout = new QVBoxLayout();
    setLayout(pMainLayout);

    QHBoxLayout *pComboBoxLayout = new QHBoxLayout();

    QGroupBox *pComboBoxGroupBox = new QGroupBox();
    pMainLayout->addWidget(pComboBoxGroupBox);

    m_pAutomaticModeButton = new QPushButton("Start");
    pComboBoxLayout->addWidget(m_pAutomaticModeButton);

    QLabel *pUpdatePeriodLabel = new QLabel("Update period (secs) : ");
    pComboBoxLayout->addWidget(pUpdatePeriodLabel);

    m_pUpdatePeriodSpinBox = new QSpinBox();
    m_pUpdatePeriodSpinBox->setValue(5);
    pComboBoxLayout->addWidget(m_pUpdatePeriodSpinBox);

    connect(m_pAutomaticModeButton, SIGNAL(clicked()), this, SLOT(handleAutomaticModeButtonClicked()));
    connect(m_pUpdatePeriodSpinBox, SIGNAL(valueChanged(int)), this, SLOT(handleAutomaticModeValueChanged(int)));
    connect(m_pJobInterface, SIGNAL(statusReceived(const QString &)), this, SLOT(updateStatus(const QString &)));

    QSpacerItem *p_HSpacer = new QSpacerItem(1, 0, QSizePolicy::Expanding, QSizePolicy::Minimum);
    pComboBoxLayout->addSpacerItem(p_HSpacer);

    QLabel *pKillComboBoxCaption = new QLabel("Set Kill Method");
    pComboBoxLayout->addWidget(pKillComboBoxCaption);

    m_pKillComboBoxWidget = new QComboBox();
    m_pKillComboBoxWidget->addItem("HUP (Hang Up): 1", 1);
    m_pKillComboBoxWidget->addItem("INT (Interrupt): 2", 2);
    m_pKillComboBoxWidget->addItem("QUIT (Quit): 3", 3);
    m_pKillComboBoxWidget->addItem("ABRT (Abort): 6", 6);
    m_pKillComboBoxWidget->addItem("KILL (Non-ignorable kill): 9", 9);
    m_pKillComboBoxWidget->addItem("ALRM (Alarm Clock): 14", 14);
    m_pKillComboBoxWidget->addItem("TERM (Software Term Signal): 15", 15);
    m_pKillComboBoxWidget->setCurrentIndex(1); // Default: Interrupt = kill -2

    pComboBoxLayout->addWidget(m_pKillComboBoxWidget);
    pComboBoxGroupBox->setLayout(pComboBoxLayout);

    m_pTreeWidget = new QTreeWidget();
    pMainLayout->addWidget(m_pTreeWidget);

    m_pTreeWidget->setSelectionMode(QAbstractItemView::ExtendedSelection);
    m_pTreeWidget->setColumnCount(4);
    m_pTreeWidget->setHeaderLabels(QStringList() << "Job Control" << "Program Name" << "PID" << "Status");

    // Create Buttons
    QWidget *pButtonWidget = new QWidget();
    pMainLayout->addWidget(pButtonWidget);

    QHBoxLayout *pButtonHLayout = new QHBoxLayout();
    pButtonWidget->setLayout(pButtonHLayout);

    m_pLoadFileButton = new QPushButton("Load file");
    pButtonHLayout->addWidget(m_pLoadFileButton);
    connect(m_pLoadFileButton, SIGNAL(clicked()), this, SLOT(loadJsonFile()));

    m_pReloadFileButton = new QPushButton("Reload file");
    pButtonHLayout->addWidget(m_pReloadFileButton);
    connect(m_pReloadFileButton, SIGNAL(clicked()), this, SLOT(reloadJsonFile()));

    m_pOpenLogFileButton = new QPushButton("Open LogFile");
    pButtonHLayout->addWidget(m_pOpenLogFileButton);
    connect(m_pOpenLogFileButton, SIGNAL(clicked()), this, SLOT(openLogFile()));

    QSpacerItem *p_HButtonSpacer = new QSpacerItem(1, 0, QSizePolicy::Expanding, QSizePolicy::Minimum);
    pButtonHLayout->addSpacerItem(p_HButtonSpacer);

    m_pUpdateButton = new QPushButton("Update");
    pButtonHLayout->addWidget(m_pUpdateButton);
    connect(m_pUpdateButton, SIGNAL(clicked()), this, SLOT(updateJobStatus()));

    // Create Menus / Menus Entries
    createActions();
    createMenus();

    // Shortcut for closing the window
    QShortcut *closeShortcut = new QShortcut(QKeySequence(Qt::CTRL + Qt::Key_W), this);
    connect(closeShortcut, SIGNAL(activated()), this, SLOT(close()));
}

//-------------------------------------------------------------------------------------------------

DQMJobInterfaceWidget::~DQMJobInterfaceWidget()
{
    delete m_pJobInterface;
}

//-------------------------------------------------------------------------------------------------

const std::string &DQMJobInterfaceWidget::getCurrentJsonFile() const
{
    return m_currentJsonFile;
}

//-------------------------------------------------------------------------------------------------

DQMJobInterface *DQMJobInterfaceWidget::getJobInterface() const
{
    return m_pJobInterface;
}

//-------------------------------------------------------------------------------------------------

void DQMJobInterfaceWidget::createActions()
{
    m_pLoadFileAction = new QAction("Load File", this);
    connect(m_pLoadFileAction, SIGNAL(triggered()), this, SLOT(loadJsonFile()));

    m_pReloadFileAction = new QAction("Reload File", this);
    connect(m_pReloadFileAction, SIGNAL(triggered()), this, SLOT(reloadJsonFile()));

    m_pOpenLogFileAction = new QAction("Open LogFile", this);
    connect(m_pOpenLogFileAction, SIGNAL(triggered()), this, SLOT(openLogFile()));

    m_pStartHostJobsAction = new QAction("Start host jobs", this);
    connect(m_pStartHostJobsAction, SIGNAL(triggered()), this, SLOT(startHostJobs()));

    m_pClearHostJobsAction = new QAction("Kill host jobs", this);
    connect(m_pClearHostJobsAction, SIGNAL(triggered()), this, SLOT(clearHostJobs()));

    m_pKillJobAction = new QAction("Kill selected job(s)", this);
    connect(m_pKillJobAction, SIGNAL(triggered()), this, SLOT(killSelectedJob()));

    m_pRestartJobAction = new QAction("Restart selected job(s)", this);
    connect(m_pRestartJobAction, SIGNAL(triggered()), this, SLOT(restartSelectedJob()));

    m_pStartJobAction = new QAction("Start selected job(s)", this);
    connect(m_pStartJobAction, SIGNAL(triggered()), this, SLOT(startSelectedJob()));

    m_pClearAllJobsAction = new QAction("Kill all jobs", this);
    connect(m_pClearAllJobsAction, SIGNAL(triggered()), this, SLOT(clearAllJobs()));

    m_pRestartAllJobsAction = new QAction("Restart all jobs", this);
    connect(m_pRestartAllJobsAction, SIGNAL(triggered()), this, SLOT(restartAllJobs()));

    m_pRestartHostJobsAction = new QAction("Restart host jobs", this);
    connect(m_pRestartHostJobsAction, SIGNAL(triggered()), this, SLOT(restartHostJobs()));

    m_pStartAllJobsAction = new QAction("Start all jobs", this);
    connect(m_pStartAllJobsAction, SIGNAL(triggered()), this, SLOT(startAllJobs()));

    m_pUpdateAction = new QAction("Update jobs", this);
    connect(m_pUpdateAction, SIGNAL(triggered()), this, SLOT(updateJobStatus()));
}

//-------------------------------------------------------------------------------------------------

void DQMJobInterfaceWidget::createMenus()
{
    m_pMenuBar = new QMenuBar();
    m_pFileMenu = m_pMenuBar->addMenu("&File");
    m_pFileMenu->addAction(m_pLoadFileAction);
    m_pFileMenu->addAction(m_pReloadFileAction);
}

//-------------------------------------------------------------------------------------------------

void DQMJobInterfaceWidget::contextMenuEvent(QContextMenuEvent *event)
{
    m_pContextMenu = new QMenu();
    m_pContextMenu->addAction(m_pStartHostJobsAction);
    m_pContextMenu->addAction(m_pRestartHostJobsAction);
    m_pContextMenu->addAction(m_pClearHostJobsAction);

    m_pContextMenu->addSeparator();
    m_pContextMenu->addAction(m_pKillJobAction);
    m_pContextMenu->addAction(m_pRestartJobAction);
    m_pContextMenu->addAction(m_pStartJobAction);

    m_pContextMenu->addSeparator();
    m_pContextMenu->addAction(m_pClearAllJobsAction);
    m_pContextMenu->addAction(m_pRestartAllJobsAction);
    m_pContextMenu->addAction(m_pStartAllJobsAction);

    m_pContextMenu->addSeparator();
    m_pContextMenu->addAction(m_pOpenLogFileAction);
    m_pContextMenu->addAction(m_pUpdateAction);

    m_pStartHostJobsAction->setEnabled(false);
    m_pRestartHostJobsAction->setEnabled(false);
    m_pClearHostJobsAction->setEnabled(false);
    m_pKillJobAction->setEnabled(false);
    m_pRestartJobAction->setEnabled(false);
    m_pStartJobAction->setEnabled(false);
    m_pOpenLogFileAction->setEnabled(false);

    // Activate items as needed
    QTreeWidgetItem* pCurrentItem = m_pTreeWidget->currentItem();

    if (NULL == pCurrentItem)
    {
        m_pContextMenu->exec(event->globalPos());
        return;
    }

    if (pCurrentItem->data(0, Qt::UserRole).value<int>() == HOST_ITEM)
    {
        m_pStartHostJobsAction->setEnabled(true);
        m_pRestartHostJobsAction->setEnabled(true);
        m_pClearHostJobsAction->setEnabled(true);
    }
    else if (pCurrentItem->data(0, Qt::UserRole).value<int>() == JOB_ITEM)
    {
        QString status = pCurrentItem->text(STATUS).at(0);

        if (status.isEmpty())
            return;
        if (pCurrentItem->text(PID).toInt())
            m_pOpenLogFileAction->setEnabled(true);

        if ( status == "X") //Dead
        {
            if (pCurrentItem->text(PID).toInt())
                m_pRestartJobAction->setEnabled(true);
            else
                m_pStartJobAction->setEnabled(true);
        }
        else
        {
            m_pKillJobAction->setEnabled(true);
            m_pRestartJobAction->setEnabled(true);
        }
    }

    m_pContextMenu->exec(event->globalPos());
}

//-------------------------------------------------------------------------------------------------

void DQMJobInterfaceWidget::loadJsonFile()
{
    QString fileName  = QFileDialog::getOpenFileName(this, "Load file");

    if (fileName.isEmpty())
        return;

    loadJsonFile(fileName.toStdString());
}

//-------------------------------------------------------------------------------------------------

void DQMJobInterfaceWidget::loadJsonFile(const std::string &fileName)
{
    if (fileName.empty())
        return;

    if (m_pTreeWidget->topLevelItemCount() != 0)
    {
        QMessageBox::StandardButton button =
            QMessageBox::warning(this, "Load json file",
                                 "WARNING !\n"
                                 "The process table is not empty. Some of the processes are maybe running.\n\n"
                                 "Do you want to kill all running jobs ?",
                                 QMessageBox::Yes | QMessageBox::No | QMessageBox::Cancel,
                                 QMessageBox::Cancel);

        switch (button)
        {
        case QMessageBox::Yes:
            this->clearAllJobs();
            break;
        case QMessageBox::No:
            break;
        case QMessageBox::Cancel:
        default:
            return;
        }
    }

    m_pJobInterface->loadJSON(fileName);
    const Json::Value &root(m_pJobInterface->getRoot());
    loadJson(root);

    m_currentJsonFile = fileName;

    updateJobStatus();
}

//-------------------------------------------------------------------------------------------------

void DQMJobInterfaceWidget::reloadJsonFile()
{
    if (m_currentJsonFile.empty())
        return;

    loadJsonFile(m_currentJsonFile);
}

//-------------------------------------------------------------------------------------------------

void DQMJobInterfaceWidget::openLogFile()
{
    
    QList<QTreeWidgetItem*> selectedItems(m_pTreeWidget->selectedItems());
    if ( selectedItems.isEmpty() )
        return;

    for (int i = 0 ; i < selectedItems.size() ; i++)
    {
        QTreeWidgetItem* pSelectedItem = selectedItems.at(i);

        if ( ! pSelectedItem )
            return;

        QString pidStr = pSelectedItem->text(PID);
        QString jobName = pSelectedItem->text(NAME);

        if ( pidStr.isEmpty() || jobName.isEmpty() )
            return;

        QString jobHostName = pSelectedItem->parent()->text(NAME);

        DQMJobInterfaceLogFileWidget *pLogFileWidget = new DQMJobInterfaceLogFileWidget(m_pJobInterface, jobHostName, jobName, pidStr);
        pLogFileWidget->setAttribute(Qt::WA_DeleteOnClose, true);
        QString titleStr = "LogFile for PID " + pidStr + ", program '" + jobName + "' on host '" + jobHostName + "'" ;
        pLogFileWidget->setWindowTitle(titleStr);
        pLogFileWidget->resize(1000, 700);
        pLogFileWidget->show();
    }
}

//-------------------------------------------------------------------------------------------------
void DQMJobInterfaceWidget::closeEvent(QCloseEvent* closeEvent)
{
    closeEvent->accept();
    qApp->quit();
}

//-------------------------------------------------------------------------------------------------
void DQMJobInterfaceWidget::startHostJobs()
{
    QList<QTreeWidgetItem*> selectedItems(m_pTreeWidget->selectedItems());

    if ( selectedItems.isEmpty() )
        return;

    QStringList nonRunningJobControls;

    for (int i = 0 ; i < selectedItems.size() ; i++)
    {
        QTreeWidgetItem* pSelectedItem = selectedItems.at(i);

        if ( ! pSelectedItem )
            continue;

        if ( pSelectedItem->data(0, Qt::UserRole).value<int>() != HOST_ITEM )
            continue;

        QString hostName = pSelectedItem->text(NAME);

        if ( ! this->jobControlExists(hostName.toStdString()) )
        {
            nonRunningJobControls << hostName;
            continue;
        }

        m_pJobInterface->startJobs(hostName.toStdString());
    }

    if ( ! nonRunningJobControls.isEmpty() )
        popupMissingJobControls(nonRunningJobControls);
}

//-------------------------------------------------------------------------------------------------

void DQMJobInterfaceWidget::startSelectedJob()
{
    QList<QTreeWidgetItem*> selectedItems(m_pTreeWidget->selectedItems());

    if ( selectedItems.isEmpty() )
        return;

    QStringList nonRunningJobControls;

    for (int i = 0 ; i < selectedItems.size() ; i++)
    {
        QTreeWidgetItem* pSelectedItem = selectedItems.at(i);

        if ( ! pSelectedItem )
            continue;

        if (pSelectedItem->data(0, Qt::UserRole).value<int>() != JOB_ITEM)
            continue;

        QString hostName = pSelectedItem->parent()->text(NAME);
        QString jobName = pSelectedItem->text(NAME);

        if ( ! this->jobControlExists(hostName.toStdString()) )
        {
            nonRunningJobControls << hostName;
            continue;
        }

        m_pJobInterface->startJob(hostName.toStdString(), jobName.toStdString());
    }

    if ( ! nonRunningJobControls.isEmpty() )
        popupMissingJobControls(nonRunningJobControls);
}

//-------------------------------------------------------------------------------------------------

void DQMJobInterfaceWidget::startAllJobs()
{
    const Json::Value &root(m_pJobInterface->getRoot());
    StringVector hostList = root["HOSTS"].getMemberNames();

    QStringList nonRunningJobControls = getNonRunningJobControls();

    if (!nonRunningJobControls.isEmpty())
        popupMissingJobControls(nonRunningJobControls);

    // loop over hosts
    for (StringVector::iterator iter = hostList.begin(), endIter = hostList.end() ;
            endIter != iter ; ++iter)
    {
        m_pJobInterface->startJobs(*iter);
    }
}

//-------------------------------------------------------------------------------------------------

void DQMJobInterfaceWidget::clearHostJobs()
{
    QList<QTreeWidgetItem*> selectedItems(m_pTreeWidget->selectedItems());

    if ( selectedItems.isEmpty() )
        return;

    QStringList nonRunningJobControls;

    for (int i = 0 ; i < selectedItems.size() ; i++)
    {
        QTreeWidgetItem* pSelectedItem = selectedItems.at(i);

        if ( ! pSelectedItem )
            continue;

        if (pSelectedItem->data(0, Qt::UserRole).value<int>() != HOST_ITEM)
            continue;

        QString hostName = pSelectedItem->text(NAME);

        if ( ! this->jobControlExists(hostName.toStdString()) )
        {
            nonRunningJobControls << hostName;
            continue;
        }

        m_pJobInterface->clearHostJobs(hostName.toStdString());
    }

    if ( ! nonRunningJobControls.isEmpty() )
        popupMissingJobControls(nonRunningJobControls);
}

//-------------------------------------------------------------------------------------------------

void DQMJobInterfaceWidget::clearAllJobs()
{
    QStringList nonRunningJobControls = getNonRunningJobControls();

    if (!nonRunningJobControls.isEmpty())
        popupMissingJobControls(nonRunningJobControls);

    m_pJobInterface->clearAllJobs();
}

//-------------------------------------------------------------------------------------------------

void DQMJobInterfaceWidget::killSelectedJob()
{
    QComboBox* pKillItem = m_pKillComboBoxWidget;
    QVariant sigVar = pKillItem->itemData(pKillItem->currentIndex());
    uint32_t sig = sigVar.toUInt();

    QList<QTreeWidgetItem*> selectedItems(m_pTreeWidget->selectedItems());

    if ( selectedItems.isEmpty() )
        return;

    QStringList nonRunningJobControls;

    for (int i = 0 ; i < selectedItems.size() ; i++)
    {
        QTreeWidgetItem* pSelectedItem = selectedItems.at(i);

        if ( ! pSelectedItem )
            continue;

        if (pSelectedItem->data(0, Qt::UserRole).value<int>() != JOB_ITEM)
            continue;

        QString hostName = pSelectedItem->parent()->text(NAME);
        QString pidStr = pSelectedItem->text(PID);

        if ( ! this->jobControlExists(hostName.toStdString()) )
        {
            nonRunningJobControls << hostName;
            continue;
        }

        if (pidStr.isEmpty())
            continue;

        uint32_t pid = pidStr.toUInt();

        m_pJobInterface->killJob(hostName.toStdString(), pid, sig);
    }

    if ( ! nonRunningJobControls.isEmpty() )
        popupMissingJobControls(nonRunningJobControls);
}

//-------------------------------------------------------------------------------------------------

void DQMJobInterfaceWidget::restartSelectedJob()
{
    QComboBox* pKillItem = m_pKillComboBoxWidget;
    QVariant sigVar = pKillItem->itemData(pKillItem->currentIndex());
    uint32_t sig = sigVar.toUInt();

    QList<QTreeWidgetItem*> selectedItems(m_pTreeWidget->selectedItems());

    if ( selectedItems.isEmpty() )
        return;

    QStringList nonRunningJobControls;

    for (int i = 0 ; i < selectedItems.size() ; i++)
    {
        QTreeWidgetItem* pSelectedItem = selectedItems.at(i);

        if ( ! pSelectedItem )
            continue;

        if (pSelectedItem->data(0, Qt::UserRole).value<int>() != JOB_ITEM)
            continue;

        QString hostName = pSelectedItem->parent()->text(NAME);
        QString jobName = pSelectedItem->text(NAME);
        QString pidStr = pSelectedItem->text(PID);

        if ( ! this->jobControlExists(hostName.toStdString()) )
        {
            nonRunningJobControls << hostName;
            continue;
        }

        if (pidStr.isEmpty())
            continue;

        uint32_t pid = pidStr.toUInt();

        m_pJobInterface->restartJob(hostName.toStdString(), jobName.toStdString(), pid, sig);
    }

    if ( ! nonRunningJobControls.isEmpty() )
        popupMissingJobControls(nonRunningJobControls);
}

//-------------------------------------------------------------------------------------------------

void DQMJobInterfaceWidget::restartHostJobs()
{
    QComboBox* pKillItem = m_pKillComboBoxWidget;
    QVariant sigVar = pKillItem->itemData(pKillItem->currentIndex());
    uint32_t sig = sigVar.toUInt();

    QList<QTreeWidgetItem*> selectedItems(m_pTreeWidget->selectedItems());

    if ( selectedItems.isEmpty() )
        return;

    QStringList nonRunningJobControls;

    for (int i = 0 ; i < selectedItems.size() ; i++)
    {
        QTreeWidgetItem* pSelectedItem = selectedItems.at(i);

        if ( ! pSelectedItem )
            continue;

        if (pSelectedItem->data(0, Qt::UserRole).value<int>() != HOST_ITEM)
            continue;

        QString hostName = pSelectedItem->text(NAME);

        if ( ! this->jobControlExists(hostName.toStdString()) )
        {
            nonRunningJobControls << hostName;
            continue;
        }

        for (unsigned int j = 0 ; j < pSelectedItem->childCount() ; j++)
        {
            QTreeWidgetItem *pJobItem = pSelectedItem->child(j);

            QString jobName = pJobItem->text(NAME);
            QString pidStr = pJobItem->text(PID);

            if (pidStr.isEmpty())
                continue;

            uint32_t pid = pidStr.toUInt();

            m_pJobInterface->restartJob(hostName.toStdString(), jobName.toStdString(), pid, sig);
        }
    }

    if ( ! nonRunningJobControls.isEmpty() )
        popupMissingJobControls(nonRunningJobControls);
}

//-------------------------------------------------------------------------------------------------

void DQMJobInterfaceWidget::restartAllJobs()
{
    QComboBox* pKillItem = m_pKillComboBoxWidget;
    QVariant sigVar = pKillItem->itemData(pKillItem->currentIndex());
    uint32_t sig = sigVar.toUInt();

    QStringList nonRunningJobControls = getNonRunningJobControls();

    if (!nonRunningJobControls.isEmpty())
        popupMissingJobControls(nonRunningJobControls);

    // loop over hosts and jobs
    // and restart them if the pid is defined
    for (unsigned int h = 0 ; h < m_pTreeWidget->topLevelItemCount() ; h++)
    {
        QTreeWidgetItem *pHostItem = m_pTreeWidget->topLevelItem(h);

        QString hostName = pHostItem->text(NAME);

        for (unsigned int j = 0 ; j < pHostItem->childCount() ; j++)
        {
            QTreeWidgetItem *pJobItem = pHostItem->child(j);

            QString jobName = pJobItem->text(NAME);
            QString pidStr = pJobItem->text(PID);

            if (pidStr.isEmpty())
                continue;

            uint32_t pid = pidStr.toUInt();

            m_pJobInterface->restartJob(hostName.toStdString(), jobName.toStdString(), pid, sig);
        }
    }
}

//-------------------------------------------------------------------------------------------------

void DQMJobInterfaceWidget::updateJobStatus()
{
    m_pJobInterface->status();

    struct timespec timesleep;
    timesleep.tv_sec = 0;
    timesleep.tv_nsec = 500000000L;
    nanosleep(&timesleep, NULL);

    this->updateStatus(m_pJobInterface->getProcessStatusValue());
}

//-------------------------------------------------------------------------------------------------

void DQMJobInterfaceWidget::loadJson(const Json::Value &root)
{
    m_pTreeWidget->clear();

    StringVector hostList = root["HOSTS"].getMemberNames();

    // loop over hosts
    for (StringVector::iterator iter = hostList.begin(), endIter = hostList.end() ;
            endIter != iter ; ++iter)
    {
        const Json::Value &host(root["HOSTS"][*iter]);

        QStringList name((*iter).c_str());

        QTreeWidgetItem *pHostItem = new QTreeWidgetItem(name);

        pHostItem->setData(0, Qt::UserRole, HOST_ITEM);
        m_pTreeWidget->addTopLevelItem(pHostItem);

        // loop over jobs host
        for (unsigned int j = 0 ; j < host.size() ; j++)
        {
            QStringList jobHeader;
            jobHeader << host[j]["NAME"].asString().c_str() << host[j]["PROGRAM"].asString().c_str() << host[j]["PID"].asString().c_str() << host[j]["STATUS"].asString().c_str() ;

            QTreeWidgetItem *pJobItem = new QTreeWidgetItem(jobHeader);

            pJobItem->setData(NAME, Qt::UserRole, JOB_ITEM);
            pJobItem->setData(PROG_NAME, Qt::UserRole, JOB_PROGRAM_NAME_ITEM);
            pJobItem->setData(PID, Qt::UserRole, JOB_PID_ITEM);
            pJobItem->setData(STATUS, Qt::UserRole, JOB_STATUS_ITEM);

            pHostItem->addChild(pJobItem);

            QTreeWidgetItem *pEnvironmentItem = new QTreeWidgetItem(QStringList("ENV"));
            pEnvironmentItem->setData(0, Qt::UserRole, JOB_ENV_ITEM);
            pJobItem->addChild(pEnvironmentItem);

            const Json::Value &envJsonValue = host[j]["ENV"];

            for (unsigned int e = 0 ; e < envJsonValue.size() ; e++)
            {
                QString env(envJsonValue[e].asString().c_str());

                QStringList envVarHeader;
                envVarHeader << env;

                QTreeWidgetItem *pEnvVarItem = new QTreeWidgetItem(envVarHeader);
                pEnvVarItem->setData(0, Qt::UserRole, VARIABLE_ITEM);
                pEnvironmentItem->addChild(pEnvVarItem);
            }

            QTreeWidgetItem *pArgsItem = new QTreeWidgetItem(QStringList("ARGS"));
            pArgsItem->setData(0, Qt::UserRole, JOB_ARGS_ITEM);
            pJobItem->addChild(pArgsItem);

            const Json::Value &argsJsonValue = host[j]["ARGS"];

            for (unsigned int e = 0 ; e < argsJsonValue.size() ; e++)
            {
                QString arg(argsJsonValue[e].asString().c_str());

                QStringList argVarHeader;
                argVarHeader << arg;

                QTreeWidgetItem *pArgVarItem = new QTreeWidgetItem(argVarHeader);
                pArgVarItem->setData(0, Qt::UserRole, VARIABLE_ITEM);
                pArgsItem->addChild(pArgVarItem);
            }
        }

        pHostItem->setExpanded(true);
    }

    m_pTreeWidget->header()->resizeSections(QHeaderView::ResizeToContents);
}

//-------------------------------------------------------------------------------------------------

void DQMJobInterfaceWidget::updateStatus(const Json::Value &value)
{
    QMap<QString, QColor> stateToColorMap;
    stateToColorMap["Z"] = QColor(Qt::red); // zombie
    stateToColorMap["T"] = QColor(Qt::darkRed); // traced or stopped
    stateToColorMap["R"] = QColor(Qt::green); // running
    stateToColorMap["D"] = QColor(Qt::darkGreen); // un-interruptible sleep
    stateToColorMap["S"] = QColor(Qt::darkGreen); // interruptible sleep
    stateToColorMap["X"] = QColor(Qt::red); // interruptible sleep

    for (unsigned int i = 0 ; i < m_pTreeWidget->topLevelItemCount() ; i++)
    {
        QTreeWidgetItem *pHostItem = m_pTreeWidget->topLevelItem(i);

        std::string hostName = pHostItem->text(NAME).toStdString();

        for (unsigned int j = 0 ; j < pHostItem->childCount() ; j++)
        {
            QTreeWidgetItem *pJobItem = pHostItem->child(j);

            std::string jobName = pJobItem->text(NAME).toStdString();

            bool found = false;

            for (unsigned int v = 0 ; v < value.size() ; v++)
            {
                std::string vHost = value[v]["HOST"].asString();
                std::string vJobName = value[v]["NAME"].asString();
                uint32_t vJobPid = value[v]["PID"].asUInt();
                std::string vJobStatus = value[v]["STATUS"].asString();

                if (vHost == hostName && vJobName == jobName)
                {
                    pJobItem->setText(STATUS, QString(vJobStatus.c_str()).trimmed());
                    pJobItem->setText(PID, QString::number(vJobPid));

                    found = true;
                    break;
                }
            }

            if (!found)
            {
                pJobItem->setText(STATUS, "X (dead)");
                pJobItem->setText(PID, "");
            }

            // cases available in /proc/pid/status file
            QMap<QString, QColor>::iterator findIter = stateToColorMap.find(pJobItem->text(STATUS).at(0));

            if (findIter != stateToColorMap.end())
                pJobItem->setData(STATUS, Qt::ForegroundRole, QBrush(findIter.value()));
            else
                pJobItem->setData(STATUS, Qt::ForegroundRole, QBrush(Qt::black));
        }

    }

    m_pTreeWidget->header()->resizeSections(QHeaderView::ResizeToContents);
}

//-------------------------------------------------------------------------------------------------

void DQMJobInterfaceWidget::handleAutomaticModeButtonClicked()
{
    if (m_pJobInterface->started())
    {
        m_pJobInterface->stopUpdate();
        m_pAutomaticModeButton->setText("Start");
    }
    else
    {
        int nSeconds = m_pUpdatePeriodSpinBox->value();
        m_pJobInterface->startUpdate(nSeconds);
        m_pAutomaticModeButton->setText("Stop");
    }
}

//-------------------------------------------------------------------------------------------------

void DQMJobInterfaceWidget::handleAutomaticModeValueChanged(int value)
{
    if (m_pJobInterface->started())
    {
        m_pJobInterface->stopUpdate();
        m_pJobInterface->startUpdate(value);
    }
}

//-------------------------------------------------------------------------------------------------

void DQMJobInterfaceWidget::updateStatus(const QString &hostName)
{
    const Json::Value value = m_pJobInterface->processStatus(hostName.toStdString())["JOBS"];
    QTreeWidgetItem *pHostItem = 0;

    for (unsigned int i = 0 ; i < m_pTreeWidget->topLevelItemCount() ; i++)
    {
        QTreeWidgetItem *pItem = m_pTreeWidget->topLevelItem(i);

        if (hostName == pItem->text(NAME))
            pHostItem = pItem;
    }

    if (!pHostItem)
        return;

    QMap<QString, QColor> stateToColorMap;
    stateToColorMap["Z"] = QColor(Qt::red); // zombie
    stateToColorMap["T"] = QColor(Qt::darkRed); // traced or stopped
    stateToColorMap["R"] = QColor(Qt::green); // running
    stateToColorMap["D"] = QColor(Qt::darkGreen); // un-interruptible sleep
    stateToColorMap["S"] = QColor(Qt::darkGreen); // interruptible sleep
    stateToColorMap["X"] = QColor(Qt::red); // interruptible sleep

    for (unsigned int j = 0 ; j < pHostItem->childCount() ; j++)
    {
        QTreeWidgetItem *pJobItem = pHostItem->child(j);

        std::string jobName = pJobItem->text(NAME).toStdString();

        bool found = false;

        for (unsigned int v = 0 ; v < value.size() ; v++)
        {
            std::string vHost = value[v]["HOST"].asString();
            std::string vJobName = value[v]["NAME"].asString();
            uint32_t vJobPid = value[v]["PID"].asUInt();
            std::string vJobStatus = value[v]["STATUS"].asString();

            if (vJobName == jobName)
            {
                pJobItem->setText(STATUS, QString(vJobStatus.c_str()).trimmed());
                pJobItem->setText(PID, QString::number(vJobPid));

                found = true;
                break;
            }
        }

        if (!found)
        {
            pJobItem->setText(STATUS, "X (dead)");
            pJobItem->setText(PID, "");
        }

        // cases available in /proc/pid/status file
        QMap<QString, QColor>::iterator findIter = stateToColorMap.find(pJobItem->text(STATUS).at(0));

        if (findIter != stateToColorMap.end())
            pJobItem->setData(STATUS, Qt::ForegroundRole, QBrush(findIter.value()));
        else
            pJobItem->setData(STATUS, Qt::ForegroundRole, QBrush(Qt::black));
    }
}

//-------------------------------------------------------------------------------------------------

bool DQMJobInterfaceWidget::jobControlExists(const std::string &hostName) const
{
    // Look for DB server
    DimBrowser browser;

    std::string jobControlName = "/DJCDQM/" + hostName + "/JOBSTATUS";
    int nServices = browser.getServices(jobControlName.c_str());

    return (nServices != 0);
}

//-------------------------------------------------------------------------------------------------

QStringList DQMJobInterfaceWidget::getNonRunningJobControls() const
{
    QStringList missingJobControlList;

    for (int i = 0 ; i < m_pTreeWidget->topLevelItemCount() ; i++)
    {
        QString hostName = m_pTreeWidget->topLevelItem(i)->text(0);

        if (!this->jobControlExists(hostName.toStdString()))
            missingJobControlList << hostName;
    }

    return missingJobControlList;
}

//-------------------------------------------------------------------------------------------------

void DQMJobInterfaceWidget::popupMissingJobControl(const QString &hostName)
{
    QMessageBox::warning(this, "Job control not running !",
                         "ERROR !\n\n"
                         "The job control on '" + hostName + "' is not running (or crashed).\n"
                         "Please, (re)start it !");
}

//-------------------------------------------------------------------------------------------------

void DQMJobInterfaceWidget::popupMissingJobControls(const QStringList &hostNameList)
{
    QString message = "ERROR !\n\n"
                      "The following job controls are not running (or crashed) : \n";

    for (int i = 0 ; i < hostNameList.size() ; i++)
        message += "   * " + hostNameList.at(i) + "\n";

    message += "Please, check the job controls status on the different servers "
               "and restart them if needed";

    QMessageBox::warning(this, "Job controls not running !", message);
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

DQMJobInterfaceLogFileWidget::DQMJobInterfaceLogFileWidget(DQMJobInterface *pParent, QString jobHostName, QString jobName, QString pidStr ):
    QWidget(NULL)
{
    m_pJobInterface = pParent;
    setLayout(new QVBoxLayout());

    QGroupBox *pLogFileBox = new QGroupBox();
    QGroupBox *pOptionBox = new QGroupBox();
    
    QVBoxLayout *pLogVLayout = new QVBoxLayout();
    pLogFileBox->setLayout(pLogVLayout);

    QGridLayout *pOptionGridLayout = new QGridLayout();
    // QHBoxLayout *pUpdateHLayout = new QHBoxLayout();
    pOptionBox->setLayout(pOptionGridLayout);

    layout()->addWidget(pOptionBox);
    layout()->addWidget(pLogFileBox);

    QLabel* pTailLabel = new QLabel("Lines to tail: ");
    pOptionGridLayout->addWidget(pTailLabel, 0, 0, Qt::AlignLeft);
    m_pLineNumberEdit = new QLineEdit("100");
    m_pLineNumberEdit->setMaximumWidth(50);
    m_pLineNumberEdit->setAlignment(Qt::AlignHCenter);   
    pOptionGridLayout->addWidget(m_pLineNumberEdit, 0, 1, Qt::AlignLeft);

    m_pUpdateLogButton = new QPushButton("Update");
    m_pUpdateLogButton->setMaximumWidth(150);
    pOptionGridLayout->addWidget(m_pUpdateLogButton, 0, 3, Qt::AlignLeft);
    pOptionGridLayout->setColumnStretch(3,1); // Push all widget to the left
    connect(m_pUpdateLogButton, SIGNAL(clicked()), this, SLOT(updateLogFile()));
    
    m_pFullLogCheckBox = new QCheckBox("Open full logFile", this);
    m_pFullLogCheckBox->setCheckState(Qt::Unchecked);
    pOptionGridLayout->addWidget(m_pFullLogCheckBox, 1, 0, 2, 2, Qt::AlignLeft);
    connect(m_pFullLogCheckBox, SIGNAL(toggled(bool)), this, SLOT(handleFullLogToggle(bool)));
    

    m_pLogFileEdit = new QTextEdit();
    pLogVLayout->addWidget(m_pLogFileEdit);
    connect(new QShortcut(Qt::CTRL + Qt::Key_R, m_pLogFileEdit), SIGNAL(activated()), m_pUpdateLogButton, SLOT(click()));

    m_jobHostName = jobHostName;
    m_pidStr = pidStr;
    pid_t pid = m_pidStr.toInt();

    m_pLogFileEdit->setReadOnly(true);
    m_pLogFileEdit->setTextInteractionFlags(m_pLogFileEdit->textInteractionFlags() | Qt::TextSelectableByKeyboard);
    
    // By default, tail the last 100lines of the log file 
    m_linesToTail = m_pLineNumberEdit->text().toInt();
    m_pLogFileEdit->setText( m_pJobInterface->queryLogFile( jobHostName.toStdString(), pid, m_linesToTail).c_str() );

    m_pSearchWidget = new QWidget();
    // Tried some cosmetics ...
    // m_pSearchWidget->setAttribute(Qt::WA_TranslucentBackground);
    // m_pSearchWidget->setAttribute(Qt::WA_NoSystemBackground, false);
    // m_pSearchWidget->setWindowFlags(Qt::FramelessWindowHint);
    pLogVLayout->addWidget(m_pSearchWidget);

    QHBoxLayout *pSearchHLayout = new QHBoxLayout();
    m_pSearchWidget->setLayout(pSearchHLayout);

    m_pSearchEdit = new QLineEdit();
    pSearchHLayout->addWidget(m_pSearchEdit);

    m_pCaseCheckBox = new QCheckBox("Case sensitive", this);
    m_pCaseCheckBox->setCheckState(Qt::Checked);
    pSearchHLayout->addWidget(m_pCaseCheckBox);

    QString iconDir = QString(DQMViz_DIR) + "/icons/";
    QIcon searchIcon = QIcon(iconDir + "icon-arrow-down.png");
    QPixmap pixMap = searchIcon.pixmap(QSize(65, 65));
    QTransform transform = QTransform().rotate(180);
    pixMap = pixMap.transformed(transform);
    QIcon backSearchIcon = QIcon(pixMap);

    m_pStartSearchButton = new QPushButton(searchIcon, "");
    m_pStartBackSearchButton = new QPushButton(backSearchIcon, "");

    pSearchHLayout->addWidget(m_pStartSearchButton);
    pSearchHLayout->addWidget(m_pStartBackSearchButton);
    pSearchHLayout->setAlignment(Qt::AlignTop);

    m_pSearchWidget->hide();

    QShortcut *searchShortcut = new QShortcut(QKeySequence::Find, this);
    searchShortcut->setAutoRepeat(false);
    connect(searchShortcut, SIGNAL(activated()), this, SLOT(showSearchWidget()));

    QShortcut *closeShortcut = new QShortcut(QKeySequence(Qt::CTRL + Qt::Key_W), this);
    connect(closeShortcut, SIGNAL(activated()), this, SLOT(close()));
}

//-------------------------------------------------------------------------------------------------
void DQMJobInterfaceLogFileWidget::handleFullLogToggle(bool checked)
{
    //activate/deactivate lineNumber edit if fullLogCheckBox is unchecked/checked 
    m_pLineNumberEdit->setEnabled(!checked);
    QPalette palette;
    if (checked)
    {
        palette.setColor(QPalette::Base,Qt::lightGray);
        m_pLineNumberEdit->setPalette(palette);
        m_pLineNumberEdit->setText("");
    }    
    else
    {
        palette.setColor(QPalette::Base,Qt::white);
        m_pLineNumberEdit->setPalette(palette);
        m_pLineNumberEdit->setText("100");
    }
}

//-------------------------------------------------------------------------------------------------
DQMJobInterfaceLogFileWidget::~DQMJobInterfaceLogFileWidget()
{
    m_pSearchEdit->clear();
    m_pLogFileEdit->clear();
}

//-------------------------------------------------------------------------------------------------
void DQMJobInterfaceLogFileWidget::updateLogFile()
{
    pid_t pid = m_pidStr.toInt();
    
    if (m_pFullLogCheckBox->isChecked())
        m_linesToTail = 0;
    else
        m_linesToTail = m_pLineNumberEdit->text().toInt();

    m_pLogFileEdit->setText( m_pJobInterface->queryLogFile( m_jobHostName.toStdString(), pid,m_linesToTail).c_str() );
    m_pLogFileEdit->moveCursor(QTextCursor::End);
    m_pLogFileEdit->setFocus();

}

//-------------------------------------------------------------------------------------------------
void DQMJobInterfaceLogFileWidget::showSearchWidget()
{
    if ( !m_pSearchWidget->isVisible())
    {
        m_pSearchWidget->show();
        m_pSearchEdit->setFocus();
    }
    else
    {
        m_pSearchWidget->hide();
        return;
    }

    // Either click on DownArrow or hit ENTER key to initiate search
    connect(new QShortcut(Qt::Key_Return, m_pSearchEdit), SIGNAL(activated()), m_pStartSearchButton, SLOT(click()));
    connect(m_pStartSearchButton, SIGNAL(clicked()), this, SLOT(searchString()));

    //Backward search
    // Either click on UpArrow or hit SHIFT+ENTER keys to initiate backwards search
    connect(new QShortcut(Qt::SHIFT + Qt::Key_Return, m_pSearchEdit), SIGNAL(activated()), m_pStartBackSearchButton, SLOT(click()));
    connect(m_pStartBackSearchButton, SIGNAL(clicked()), this, SLOT(searchString()));
}

//-------------------------------------------------------------------------------------------------
void DQMJobInterfaceLogFileWidget::searchString()
{
    m_caseFlags = 0; // resetFlags
    QPushButton *pButton = qobject_cast<QPushButton*>(sender());
    if (NULL == pButton)
        return;

    else if (pButton == m_pStartBackSearchButton)
        m_caseFlags |= QTextDocument::FindBackward;

    if (Qt::Checked == m_pCaseCheckBox->checkState())
        m_caseFlags |= QTextDocument::FindCaseSensitively;

    QPalette *pPalette = new QPalette(Qt::yellow);
    pPalette->setColor(QPalette::Highlight, Qt::yellow);
    m_pLogFileEdit->setPalette(*pPalette);
    bool found = m_pLogFileEdit->find( m_pSearchEdit->text(), m_caseFlags);
    if (!found)
    {
        QTextCursor::MoveOperation move;
        if (pButton == m_pStartBackSearchButton)
            move = QTextCursor::End;
        else
            move = QTextCursor::Start;

        m_pLogFileEdit->moveCursor(move);
        m_pLogFileEdit->find( m_pSearchEdit->text(), m_caseFlags);
    }
}


}

