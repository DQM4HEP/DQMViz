  /// \file DQMCanvasView.cc
/*
 *
 * DQMCanvasView.cc source template automatically generated by a class generator
 * Creation date : lun. oct. 12 2015
 *
 * This file is part of DQM4HEP libraries.
 * 
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "dqm4hep/vis/DQMCanvasView.h"
#include "dqm4hep/DQMMonitorElement.h"
#include "dqm4hep/vis/DQMMonitoring.h"
#include "dqm4hep/vis/DQMMonitoringView.h"
#include "dqm4hep/vis/DQMMonitoringController.h"
#include "dqm4hep/vis/DQMMonitoringModel.h"
#include "dqm4hep/vis/DQMCanvasArea.h"
#include "dqm4hep/vis/DQMCanvas.h"
#include "dqm4hep/vis/DQMGuiMonitorElement.h"

#include <QAction>
#include <QTabBar>
#include <QInputDialog>
#include <QString>
#include <QLineEdit>
#include <QApplication>
#include <QToolButton>
#include <QHBoxLayout>

namespace dqm4hep
{

/** DQMTabWidget class
 */
class DQMTabWidget : public QTabWidget
{
public:
	/** Constructor
	 */
	DQMTabWidget(QWidget *pParent = 0);

	/** Get the tab bar
	 */
	QTabBar *tabBar() const;
};

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

DQMTabWidget::DQMTabWidget(QWidget *pParent)
	: QTabWidget(pParent)
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

QTabBar *DQMTabWidget::tabBar() const
{
	return QTabWidget::tabBar();
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

DQMCanvasView::DQMCanvasView(DQMMonitoring *pMonitoring, QWidget *pParent) :
		QWidget(pParent),
		m_pMonitoring(pMonitoring)
{
	setLayout(new QHBoxLayout());
	m_pTabWidget = new DQMTabWidget(this);
	layout()->addWidget(m_pTabWidget);
	m_pTabWidget->installEventFilter(this);

	m_pTabWidget->setMovable(true);
	m_pTabWidget->setTabsClosable(true);

    QToolButton *pButton = new QToolButton(m_pTabWidget);
    pButton->setText("+");
    pButton->setAutoRaise(true);
    m_pTabWidget->setCornerWidget(pButton);

	this->createCanvasArea("Canvas area");

	connect(m_pTabWidget, SIGNAL(tabCloseRequested(int)), this, SLOT(removeCanvasArea(int)));
	connect(pButton, SIGNAL(clicked()), this, SLOT(createCanvasAreaAndSetCurrent()));

	installEventFilter(this);
}

//-------------------------------------------------------------------------------------------------

DQMCanvasView::~DQMCanvasView()
{
	while(m_pTabWidget->count() != 0)
	{
		DQMCanvasArea *pCanvasArea = this->getCanvasArea(0);
		m_pTabWidget->removeTab(0);
		pCanvasArea->deleteLater();
	}
}

//-------------------------------------------------------------------------------------------------

DQMMonitoring *DQMCanvasView::getMonitoring() const
{
	return m_pMonitoring;
}

//-------------------------------------------------------------------------------------------------

TiXmlElement *DQMCanvasView::toXml() const
{
	TiXmlElement *pXmlElement = new TiXmlElement("canvasView");

	for(int c=0 ; c<this->canvasAreaCount() ; c++)
	{
		DQMCanvasArea *pCanvasArea = this->getCanvasArea(c);
		std::string canvasAreaName = this->getCanvasAreaName(c);

		TiXmlElement *pCanvasAreaElement = new TiXmlElement("canvasArea");
		pXmlElement->LinkEndChild(pCanvasAreaElement);

		pCanvasAreaElement->SetAttribute("name", canvasAreaName);

		for(int i=0 ; i<pCanvasArea->canvasCount() ; i++)
		{
			DQMCanvas *pCanvas = pCanvasArea->getCanvas(i);

			int x = pCanvas->x();
			int y = pCanvas->y();
			int width = pCanvas->width();
			int height = pCanvas->height();

			TiXmlElement *pCanvasElement = new TiXmlElement("canvas");
			pCanvasAreaElement->LinkEndChild(pCanvasElement);

			pCanvasElement->SetAttribute("x", x);
			pCanvasElement->SetAttribute("y", y);
			pCanvasElement->SetAttribute("w", width);
			pCanvasElement->SetAttribute("h", height);

			if(pCanvas->isMaximized())
				pCanvasElement->SetAttribute("maximized", true);

			DQMGuiMonitorElement *pGuiMonitorElement = pCanvas->getCurrentMonitorElement();

			if(pGuiMonitorElement)
			{
				std::string collectorName = pGuiMonitorElement->getMonitorElement()->getCollectorName();
				std::string moduleName = pGuiMonitorElement->getMonitorElement()->getModuleName();
				std::string path = pGuiMonitorElement->getMonitorElement()->getPath().getPath();
				std::string name = pGuiMonitorElement->getMonitorElement()->getName();

				TiXmlElement *pMeElement = new TiXmlElement("monitorElement");
				pCanvasElement->LinkEndChild(pMeElement);

				pMeElement->SetAttribute("collector", collectorName);
				pMeElement->SetAttribute("module", moduleName);
				pMeElement->SetAttribute("path", path);
				pMeElement->SetAttribute("name", name);
			}
		}
	}

	return pXmlElement;
}

//-------------------------------------------------------------------------------------------------

void DQMCanvasView::fromXml(TiXmlElement *const pXmlElement)
{
	if(!pXmlElement)
		return;

	// manual clear
	while(m_pTabWidget->count() != 0)
	{
		DQMCanvasArea *pCanvasArea = this->getCanvasArea(0);
		m_pTabWidget->removeTab(0);
		pCanvasArea->deleteLater();
	}

	int nCreatedCanvaAreas = 0;

    TiXmlHandle elementHandle(pXmlElement);

    for (TiXmlElement *pCanvasAreaElement = elementHandle.FirstChild("canvasArea").Element(); NULL != pCanvasAreaElement;
    		pCanvasAreaElement = pCanvasAreaElement->NextSiblingElement("canvasArea"))
    {
    	std::string canvasAreaName;
        if(pCanvasAreaElement->QueryStringAttribute("name", &canvasAreaName))
            continue;

        this->createCanvasAreaAndSetCurrent(canvasAreaName);
        DQMCanvasArea *pCanvasArea = this->getCurrentCanvasArea();

        TiXmlHandle canvasAreaHandle(pCanvasAreaElement);

        for (TiXmlElement *pCanvasElement = canvasAreaHandle.FirstChild("canvas").Element(); NULL != pCanvasElement;
        		pCanvasElement = pCanvasElement->NextSiblingElement("canvas"))
        {
            TiXmlHandle canvasHandle(pCanvasElement);
            TiXmlElement *pMeElement = canvasHandle.FirstChild("monitorElement").Element();

            if(!pMeElement)
            	continue;

        	int x;
        	int y;
        	int width;
        	int height;
        	bool maximized = false;

            if(pCanvasElement->QueryIntAttribute("x", &x))
                continue;

            if(pCanvasElement->QueryIntAttribute("y", &y))
                continue;

            if(pCanvasElement->QueryIntAttribute("w", &width))
                continue;

            if(pCanvasElement->QueryIntAttribute("h", &height))
                continue;

            if(pCanvasElement->QueryValueAttribute("maximized", &maximized))
            	maximized = false;

            std::string collectorName;
            std::string moduleName;
            std::string path;
            std::string name;

            if(pMeElement->QueryStringAttribute("collector", &collectorName))
            	continue;

            if(pMeElement->QueryStringAttribute("module", &moduleName))
            	continue;

            if(pMeElement->QueryStringAttribute("path", &path))
            	continue;

            if(pMeElement->QueryStringAttribute("name", &name))
            	continue;

            DQMGuiMonitorElement *pMonitorElement =
            		this->getMonitoring()->getModel()->findMonitorElement(
            				collectorName,
            				moduleName,
            				path,
            				name);

            if(!pMonitorElement)
            {
            	// create a default one that will be updated afterward
				pMonitorElement =
						this->getMonitoring()->getModel()->createGuiMonitorElement(
								collectorName,
								moduleName,
								path,
								name);

				this->getMonitoring()->getModel()->updateMonitorElement(pMonitorElement);
            }

            DQMCanvas *pCanvas = pCanvasArea->createCanvas(pMonitorElement);
            pCanvas->move(x, y);
            pCanvas->resize(width, height);

            if(maximized)
            	pCanvas->showMaximized();
        }
    }
}

//-------------------------------------------------------------------------------------------------

DQMCanvasArea *DQMCanvasView::getCurrentCanvasArea() const
{
	return (DQMCanvasArea *) m_pTabWidget->currentWidget();
}

//-------------------------------------------------------------------------------------------------

std::string DQMCanvasView::getCurrentCanvasAreaName() const
{
	int currentIndex = m_pTabWidget->currentIndex();
	QString name = m_pTabWidget->tabText(currentIndex);

	return name.toStdString();
}

//-------------------------------------------------------------------------------------------------

DQMCanvasArea *DQMCanvasView::getCanvasArea(int index) const
{
	return (DQMCanvasArea *) m_pTabWidget->widget(index);
}

//-------------------------------------------------------------------------------------------------

int DQMCanvasView::getCanvasAreaIndex(DQMCanvasArea *pCanvasArea) const
{
	return m_pTabWidget->indexOf(pCanvasArea);
}

//-------------------------------------------------------------------------------------------------

std::string DQMCanvasView::getCanvasAreaName(int index) const
{
	return m_pTabWidget->tabText(index).toStdString();
}

//-------------------------------------------------------------------------------------------------

int DQMCanvasView::canvasAreaCount() const
{
	return m_pTabWidget->count();
}

//-------------------------------------------------------------------------------------------------

QList<DQMCanvasArea*> DQMCanvasView::canvasAreaList() const
{
	QList<DQMCanvasArea*> list;

	for(int i=0 ; i<m_pTabWidget->count() ; i++)
	{
		DQMCanvasArea *pCanvasArea = this->getCanvasArea(i);

		if(!pCanvasArea)
			continue;

		list.append(pCanvasArea);
	}

	return list;
}

//-------------------------------------------------------------------------------------------------

void DQMCanvasView::createCanvasArea(const std::string &areaName)
{
	QString name;

	if(areaName.empty())
		name = "Canvas area";
	else
		name = areaName.c_str();

	DQMCanvasArea *pCanvasArea = new DQMCanvasArea(this->getMonitoring());
	m_pTabWidget->addTab(pCanvasArea, name);
}

//-------------------------------------------------------------------------------------------------

void DQMCanvasView::createCanvasAreaAndSetCurrent(const std::string &areaName)
{
	this->createCanvasArea(areaName);
	this->setCurrentCanvasArea(m_pTabWidget->count()-1);

	if( areaName.empty() )
		this->renameCanvasAreaFromInputDialog(m_pTabWidget->count()-1);
}

//-------------------------------------------------------------------------------------------------

void DQMCanvasView::drawInCurrentArea(DQMGuiMonitorElement *pMonitorElement)
{
	DQMCanvasArea *pCanvasArea = this->getCurrentCanvasArea();
	pCanvasArea->draw(pMonitorElement);
}

//-------------------------------------------------------------------------------------------------

void DQMCanvasView::drawInArea(DQMGuiMonitorElement *pMonitorElement, int index)
{
	DQMCanvasArea *pCanvasArea = this->getCanvasArea(index);

	if(pCanvasArea)
		pCanvasArea->draw(pMonitorElement);
}

//-------------------------------------------------------------------------------------------------

void DQMCanvasView::drawInNewArea(DQMGuiMonitorElement *pMonitorElement, const std::string &areaName)
{
	this->createCanvasAreaAndSetCurrent(areaName);
	this->drawInCurrentArea(pMonitorElement);
}

//-------------------------------------------------------------------------------------------------

void DQMCanvasView::removeCanvasArea(int index)
{
	DQMCanvasArea *pCanvasArea = this->getCanvasArea(index);

	if(!pCanvasArea)
		return;

	m_pTabWidget->removeTab(index);
	pCanvasArea->deleteLater();

	if(m_pTabWidget->count() == 0)
		this->createCanvasArea();
}

//-------------------------------------------------------------------------------------------------

void DQMCanvasView::renameCanvasArea(int index, const std::string &newAreaName)
{
	m_pTabWidget->setTabText(index, newAreaName.c_str());
}

//-------------------------------------------------------------------------------------------------

void DQMCanvasView::clearArea(int index)
{
	DQMCanvasArea *pCanvasArea = this->getCanvasArea(index);

	if(!pCanvasArea)
		return;

	pCanvasArea->clear();
}

//-------------------------------------------------------------------------------------------------

void DQMCanvasView::clear()
{
	while(m_pTabWidget->count() != 0)
	{
		DQMCanvasArea *pCanvasArea = this->getCanvasArea(0);
		m_pTabWidget->removeTab(0);
		pCanvasArea->deleteLater();
	}

	this->createCanvasArea();
}

//-------------------------------------------------------------------------------------------------

void DQMCanvasView::showContextMenu(const QPoint &point)
{
    QWidget *pSelectedWidget = qApp->widgetAt(point);

    if(!pSelectedWidget)
        return;

    QMenu *pContextMenu = this->createContextMenu();
    pContextMenu->exec(point);
    pContextMenu->deleteLater();
}

//-------------------------------------------------------------------------------------------------

void DQMCanvasView::setCurrentCanvasArea(int index)
{
	m_pTabWidget->setCurrentIndex(index);
}

//-------------------------------------------------------------------------------------------------

void DQMCanvasView::moveCanvas(DQMCanvas *pCanvas, int newAreaIndex)
{
	if(!pCanvas)
		return;

	DQMCanvasArea *pCurrentCanvasArea = this->getCurrentCanvasArea();
	DQMCanvasArea *pMoveCanvasArea = this->getCanvasArea(newAreaIndex);

	if(!pMoveCanvasArea || !pCurrentCanvasArea->contains(pCanvas) || pCurrentCanvasArea == pMoveCanvasArea)
		return;

	pCurrentCanvasArea->removeCanvas(pCanvas, false);
	pMoveCanvasArea->addCanvas(pCanvas);
}

//-------------------------------------------------------------------------------------------------

QMenu *DQMCanvasView::createContextMenu() const
{
	QMenu *pContextMenu = new QMenu();

    QPoint point = m_pTabWidget->tabBar()->mapFromGlobal(QCursor::pos());
    int tabIndex = m_pTabWidget->tabBar()->tabAt(point);

	QAction *pRenameAreaAction = pContextMenu->addAction("Rename area", this, SLOT(handleRenameAreaActionTriggered()));
	QAction *pRemoveAreaAction = pContextMenu->addAction("Remove area", this, SLOT(handleRemoveAreaActionTriggered()));
	QAction *pRemoveAllAreasAction = pContextMenu->addAction("Remove all areas", this, SLOT(clear()));
	QAction *pCreateNewAreaAction = pContextMenu->addAction("Create new area", this, SLOT(createCanvasAreaAndSetCurrent()));
	QAction *pClearAreaAction = pContextMenu->addAction("Clear area", this, SLOT(handleClearAreaActionTriggered()));
	QAction *pSaveAsAction = pContextMenu->addAction("Save as", this, SLOT(handleSaveAsActionTriggered()));

	if(tabIndex < 0)
	{
		pRenameAreaAction->setEnabled(false);
		pRemoveAreaAction->setEnabled(false);
		pClearAreaAction->setEnabled(false);
		pSaveAsAction->setEnabled(false);
	}
	else
	{
		pRenameAreaAction->setData(tabIndex);
		pRemoveAreaAction->setData(tabIndex);
		pClearAreaAction->setData(tabIndex);
		pSaveAsAction->setData(tabIndex);
	}

    return pContextMenu;
}

//-------------------------------------------------------------------------------------------------

bool DQMCanvasView::eventFilter(QObject *pObject, QEvent *pEvent)
{
    if(pEvent->type() == QEvent::ContextMenu)
    {
        this->showContextMenu(this->cursor().pos());
        return true;
    }
    // Rename a tab if DoubleClick on it
    else if (pObject == m_pTabWidget->tabBar() && pEvent->type() == QEvent::MouseButtonDblClick)
    {
        QTabBar *pTabBar = m_pTabWidget->tabBar();
        QPoint p = pTabBar->mapFromGlobal(QCursor::pos());

        int index = pTabBar->tabAt(p);
        this->renameCanvasAreaFromInputDialog(index);
    }

    return QObject::eventFilter(pObject, pEvent);
}

//-------------------------------------------------------------------------------------------------

void DQMCanvasView::renameCanvasAreaFromInputDialog(int index)
{
    bool ok = false;
    QString oldAreaName = m_pTabWidget->tabText(index);

    QString newAreaName = QInputDialog::getText(this, "New canvas area name",
                                               "", QLineEdit::Normal,
                                               oldAreaName, &ok);

    if(ok)
        this->renameCanvasArea(index, newAreaName.toStdString());
}

//-------------------------------------------------------------------------------------------------

void DQMCanvasView::handleRenameAreaActionTriggered()
{
	QAction *pAction = (QAction *) sender();

	if(!pAction)
		return;

	int index = pAction->data().toInt();

	this->renameCanvasAreaFromInputDialog(index);
}

//-------------------------------------------------------------------------------------------------

void DQMCanvasView::handleRemoveAreaActionTriggered()
{
	QAction *pAction = (QAction *) sender();

	if(!pAction)
		return;

	int index = pAction->data().toInt();
	this->removeCanvasArea(index);
}

//-------------------------------------------------------------------------------------------------

void DQMCanvasView::handleClearAreaActionTriggered()
{
	QAction *pAction = (QAction *) sender();

	if(!pAction)
		return;

	int index = pAction->data().toInt();
	this->clearArea(index);
}

//-------------------------------------------------------------------------------------------------

void DQMCanvasView::handleSaveAsActionTriggered()
{
	QAction *pAction = (QAction *) sender();

	if(!pAction)
		return;

	int index = pAction->data().toInt();
	DQMCanvasArea *pCanvasArea = this->getCanvasArea(index);

	if(!pCanvasArea)
		return;

	this->getMonitoring()->getController()->saveAs(pCanvasArea);
}

} 

