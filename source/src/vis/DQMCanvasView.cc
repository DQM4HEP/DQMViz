/// \file DQMCanvasView.cc
/*
 *
 * DQMCanvasView.cc source template automatically generated by a class generator
 * Creation date : lun. oct. 12 2015
 *
 * This file is part of DQM4HEP libraries.
 *
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 *
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 *
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "dqm4hep/vis/DQMCanvasView.h"
#include "dqm4hep/DQMMonitorElement.h"
#include "dqm4hep/vis/DQMMonitoring.h"
#include "dqm4hep/vis/DQMMonitoringView.h"
#include "dqm4hep/vis/DQMMonitoringController.h"
#include "dqm4hep/vis/DQMMonitoringModel.h"
#include "dqm4hep/vis/DQMCanvasArea.h"
#include "dqm4hep/vis/DQMCanvas.h"
#include "dqm4hep/vis/DQMGuiMonitorElement.h"

#include <QAction>
#include <QInputDialog>
#include <QString>
#include <QLineEdit>
#include <QApplication>
#include <QToolButton>
#include <QHBoxLayout>

namespace dqm4hep
{

void DQMTabBar::renameCanvasArea(int index, const std::string &newAreaName)
{
  this->setTabText(index, newAreaName.c_str());
}

//-------------------------------------------------------------------------------------------------
void DQMTabBar::renameCanvasAreaFromInputDialog(int index)
{
  bool ok = false;
  QString oldAreaName = this->tabText(index);

  QString newAreaName = QInputDialog::getText(this, "New canvas area name",
                        "", QLineEdit::Normal,
                        oldAreaName, &ok);

  if (ok)
    this->renameCanvasArea(index, newAreaName.toStdString());
}

//-------------------------------------------------------------------------------------------------
void DQMTabBar::mouseDoubleClickEvent(QMouseEvent *event)
{
  const QPoint pos = this->mapFromGlobal(QCursor::pos());
  int index = this->tabAt(pos);
  this->renameCanvasAreaFromInputDialog(index);
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
DQMTabWidget::DQMTabWidget(QWidget *pParent) :
  QTabWidget(pParent)
{
  m_pTabBar = new DQMTabBar();
  setTabBar (m_pTabBar);
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

DQMCanvasView::DQMCanvasView(DQMMonitoring *pMonitoring, QWidget *pParent) :
  QWidget(pParent),
  m_pMonitoring(pMonitoring)
{
  setLayout(new QHBoxLayout());
  m_pTabWidget = new DQMTabWidget(this);
  layout()->addWidget(m_pTabWidget);
  m_pTabWidget->installEventFilter(this);

  m_pTabWidget->setMovable(true);
  m_pTabWidget->setTabsClosable(true);

  QToolButton *pButton = new QToolButton(m_pTabWidget);
  pButton->setText("+");
  pButton->setAutoRaise(true);
  m_pTabWidget->setCornerWidget(pButton);

  this->createCanvasArea("Canvas area");

  connect(m_pTabWidget, SIGNAL(tabCloseRequested(int)), this, SLOT(removeCanvasArea(int)));
  connect(pButton, SIGNAL(clicked()), this, SLOT(createCanvasAreaAndSetCurrent()));

  installEventFilter(this);
}

//-------------------------------------------------------------------------------------------------

DQMCanvasView::~DQMCanvasView()
{
	while(m_pTabWidget->count() != 0)
  {
    DQMCanvasArea *pCanvasArea = this->getCanvasArea(0);
    m_pTabWidget->removeTab(0);
    pCanvasArea->deleteLater();
  }
}

//-------------------------------------------------------------------------------------------------

DQMMonitoring *DQMCanvasView::getMonitoring() const
{
  return m_pMonitoring;
}

//-------------------------------------------------------------------------------------------------

TiXmlElement *DQMCanvasView::toXml() const
{
  TiXmlElement *pXmlElement = new TiXmlElement("canvasView");

	for(int c=0 ; c<this->canvasAreaCount() ; c++)
  {
    DQMCanvasArea *pCanvasArea = this->getCanvasArea(c);
    std::string canvasAreaName = this->getCanvasAreaName(c);

    TiXmlElement *pCanvasAreaElement = new TiXmlElement("canvasArea");
    pXmlElement->LinkEndChild(pCanvasAreaElement);

    pCanvasAreaElement->SetAttribute("name", canvasAreaName);

		for(int i=0 ; i<pCanvasArea->canvasCount() ; i++)
    {
      DQMCanvas *pCanvas = pCanvasArea->getCanvas(i);

      int x = pCanvas->x();
      int y = pCanvas->y();
      int width = pCanvas->width();
      int height = pCanvas->height();

      TiXmlElement *pCanvasElement = new TiXmlElement("canvas");
      pCanvasAreaElement->LinkEndChild(pCanvasElement);

      pCanvasElement->SetAttribute("x", x);
      pCanvasElement->SetAttribute("y", y);
      pCanvasElement->SetAttribute("w", width);
      pCanvasElement->SetAttribute("h", height);

			if(pCanvas->isMaximized())
        pCanvasElement->SetAttribute("maximized", true);

      DQMGuiMonitorElement *pGuiMonitorElement = pCanvas->getCurrentMonitorElement();

			if(pGuiMonitorElement)
      {
        std::string collectorName = pGuiMonitorElement->getMonitorElement()->getCollectorName();
        std::string moduleName = pGuiMonitorElement->getMonitorElement()->getModuleName();
        std::string path = pGuiMonitorElement->getMonitorElement()->getPath().getPath();
        std::string name = pGuiMonitorElement->getMonitorElement()->getName();

        TiXmlElement *pMeElement = new TiXmlElement("monitorElement");
        pCanvasElement->LinkEndChild(pMeElement);

        pMeElement->SetAttribute("collector", collectorName);
        pMeElement->SetAttribute("module", moduleName);
        pMeElement->SetAttribute("path", path);
        pMeElement->SetAttribute("name", name);
      }
    }
  }

  return pXmlElement;
}

//-------------------------------------------------------------------------------------------------

void DQMCanvasView::fromXml(TiXmlElement *const pXmlElement)
{
	if(!pXmlElement)
    return;

  // manual clear
	while(m_pTabWidget->count() != 0)
  {
    DQMCanvasArea *pCanvasArea = this->getCanvasArea(0);
    m_pTabWidget->removeTab(0);
    pCanvasArea->deleteLater();
  }

  int nCreatedCanvaAreas = 0;

  TiXmlHandle elementHandle(pXmlElement);

  for (TiXmlElement *pCanvasAreaElement = elementHandle.FirstChild("canvasArea").Element(); NULL != pCanvasAreaElement;
       pCanvasAreaElement = pCanvasAreaElement->NextSiblingElement("canvasArea"))
  {
    std::string canvasAreaName;
        if(pCanvasAreaElement->QueryStringAttribute("name", &canvasAreaName))
      continue;

    this->createCanvasAreaAndSetCurrent(canvasAreaName);
    DQMCanvasArea *pCanvasArea = this->getCurrentCanvasArea();

    TiXmlHandle canvasAreaHandle(pCanvasAreaElement);

    for (TiXmlElement *pCanvasElement = canvasAreaHandle.FirstChild("canvas").Element(); NULL != pCanvasElement;
         pCanvasElement = pCanvasElement->NextSiblingElement("canvas"))
    {
      TiXmlHandle canvasHandle(pCanvasElement);
      TiXmlElement *pMeElement = canvasHandle.FirstChild("monitorElement").Element();

            if(!pMeElement)
        continue;

      int x;
      int y;
      int width;
      int height;
      bool maximized = false;

            if(pCanvasElement->QueryIntAttribute("x", &x))
        continue;

            if(pCanvasElement->QueryIntAttribute("y", &y))
        continue;

            if(pCanvasElement->QueryIntAttribute("w", &width))
        continue;

            if(pCanvasElement->QueryIntAttribute("h", &height))
        continue;

            if(pCanvasElement->QueryValueAttribute("maximized", &maximized))
        maximized = false;

      std::string collectorName;
      std::string moduleName;
      std::string path;
      std::string name;

            if(pMeElement->QueryStringAttribute("collector", &collectorName))
        continue;

            if(pMeElement->QueryStringAttribute("module", &moduleName))
        continue;

            if(pMeElement->QueryStringAttribute("path", &path))
        continue;

            if(pMeElement->QueryStringAttribute("name", &name))
        continue;

      DQMGuiMonitorElement *pMonitorElement =
        this->getMonitoring()->getModel()->findMonitorElement(
          collectorName,
          moduleName,
          path,
          name);

            if(!pMonitorElement)
      {
        // create a default one that will be updated afterward
        pMonitorElement =
          this->getMonitoring()->getModel()->createGuiMonitorElement(
            collectorName,
            moduleName,
            path,
            name);

        this->getMonitoring()->getModel()->updateMonitorElement(pMonitorElement);
      }

      DQMCanvas *pCanvas = pCanvasArea->createCanvas(pMonitorElement);
      pCanvas->move(x, y);
      pCanvas->resize(width, height);

            if(maximized)
        pCanvas->showMaximized();
    }
  }
}

//-------------------------------------------------------------------------------------------------

DQMCanvasArea *DQMCanvasView::getCurrentCanvasArea() const
{
  return (DQMCanvasArea *) m_pTabWidget->currentWidget();
}

//-------------------------------------------------------------------------------------------------

std::string DQMCanvasView::getCurrentCanvasAreaName() const
{
  int currentIndex = m_pTabWidget->currentIndex();
  QString name = m_pTabWidget->tabText(currentIndex);

  return name.toStdString();
}

//-------------------------------------------------------------------------------------------------

DQMCanvasArea *DQMCanvasView::getCanvasArea(int index) const
{
  return (DQMCanvasArea *) m_pTabWidget->widget(index);
}

//-------------------------------------------------------------------------------------------------

int DQMCanvasView::getCanvasAreaIndex(DQMCanvasArea *pCanvasArea) const
{
  return m_pTabWidget->indexOf(pCanvasArea);
}

//-------------------------------------------------------------------------------------------------

std::string DQMCanvasView::getCanvasAreaName(int index) const
{
  return m_pTabWidget->tabText(index).toStdString();
}

//-------------------------------------------------------------------------------------------------

int DQMCanvasView::canvasAreaCount() const
{
  return m_pTabWidget->count();
}

//-------------------------------------------------------------------------------------------------

QList<DQMCanvasArea*> DQMCanvasView::canvasAreaList() const
{
  QList<DQMCanvasArea*> list;

	for(int i=0 ; i<m_pTabWidget->count() ; i++)
  {
    DQMCanvasArea *pCanvasArea = this->getCanvasArea(i);

		if(!pCanvasArea)
      continue;

    list.append(pCanvasArea);
  }

  return list;
}

//-------------------------------------------------------------------------------------------------

void DQMCanvasView::createCanvasArea(const std::string &areaName)
{
  QString name;

	if(areaName.empty())
    name = "Canvas area";
  else
    name = areaName.c_str();

  DQMCanvasArea *pCanvasArea = new DQMCanvasArea(this->getMonitoring());
  m_pTabWidget->addTab(pCanvasArea, name);
}

//-------------------------------------------------------------------------------------------------

void DQMCanvasView::createCanvasAreaAndSetCurrent(const std::string &areaName)
{
  this->createCanvasArea(areaName);
	this->setCurrentCanvasArea(m_pTabWidget->count()-1);

  if ( areaName.empty() )
    m_pTabWidget->tabBar()->renameCanvasAreaFromInputDialog(m_pTabWidget->count() - 1);
}

//-------------------------------------------------------------------------------------------------

void DQMCanvasView::drawInCurrentArea(DQMGuiMonitorElement *pMonitorElement)
{
  DQMCanvasArea *pCanvasArea = this->getCurrentCanvasArea();
  pCanvasArea->draw(pMonitorElement);
}

//-------------------------------------------------------------------------------------------------

void DQMCanvasView::drawInArea(DQMGuiMonitorElement *pMonitorElement, int index)
{
  DQMCanvasArea *pCanvasArea = this->getCanvasArea(index);
  m_pTabWidget->setCurrentIndex(index);

	if(pCanvasArea)
    pCanvasArea->draw(pMonitorElement);
}

//-------------------------------------------------------------------------------------------------

void DQMCanvasView::drawInNewArea(DQMGuiMonitorElement *pMonitorElement, const std::string &areaName)
{
  this->createCanvasAreaAndSetCurrent(areaName);
  this->drawInCurrentArea(pMonitorElement);
}

//-------------------------------------------------------------------------------------------------

void DQMCanvasView::removeCanvasArea(int index)
{
  DQMCanvasArea *pCanvasArea = this->getCanvasArea(index);

	if(!pCanvasArea)
    return;

  m_pTabWidget->removeTab(index);
  pCanvasArea->deleteLater();

	if(m_pTabWidget->count() == 0)
    this->createCanvasArea();
}

//-------------------------------------------------------------------------------------------------

void DQMCanvasView::clearArea(int index)
{
  DQMCanvasArea *pCanvasArea = this->getCanvasArea(index);

	if(!pCanvasArea)
    return;

  pCanvasArea->clear();
}

//-------------------------------------------------------------------------------------------------

void DQMCanvasView::clear()
{
	while(m_pTabWidget->count() != 0)
  {
    DQMCanvasArea *pCanvasArea = this->getCanvasArea(0);
    m_pTabWidget->removeTab(0);
    pCanvasArea->deleteLater();
  }

  this->createCanvasArea();
}

//-------------------------------------------------------------------------------------------------

void DQMCanvasView::showContextMenu(const QPoint &point)
{
  QWidget *pSelectedWidget = qApp->widgetAt(point);

    if(!pSelectedWidget)
    return;

  QMenu *pContextMenu = this->createContextMenu();
  pContextMenu->exec(point);
  pContextMenu->deleteLater();
}

//-------------------------------------------------------------------------------------------------

void DQMCanvasView::setCurrentCanvasArea(int index)
{
  m_pTabWidget->setCurrentIndex(index);
}

//-------------------------------------------------------------------------------------------------

void DQMCanvasView::moveCanvas(DQMCanvas *pCanvas, int newAreaIndex)
{
	if(!pCanvas)
    return;

  DQMCanvasArea *pCurrentCanvasArea = this->getCurrentCanvasArea();
  DQMCanvasArea *pMoveCanvasArea = this->getCanvasArea(newAreaIndex);

	if(!pMoveCanvasArea || !pCurrentCanvasArea->contains(pCanvas) || pCurrentCanvasArea == pMoveCanvasArea)
    return;

  pCurrentCanvasArea->removeCanvas(pCanvas, false);
  pMoveCanvasArea->addCanvas(pCanvas);
}

//-------------------------------------------------------------------------------------------------

QMenu *DQMCanvasView::createContextMenu() const
{
  QMenu *pContextMenu = new QMenu();

  QPoint point = m_pTabWidget->tabBar()->mapFromGlobal(QCursor::pos());
  int tabIndex = m_pTabWidget->tabBar()->tabAt(point); // tabindex when Cursor is on tabbar
  m_pTabWidget->setCurrentIndex(tabIndex); // Select tab when interacting with it
  int currentIndex = m_pTabWidget->currentIndex(); // current tabindex when cursor is on canvas area

  QAction *pRenameAreaAction = pContextMenu->addAction("Rename area", this, SLOT(handleRenameAreaActionTriggered()));
  QAction *pRemoveAreaAction = pContextMenu->addAction("Remove area", this, SLOT(handleRemoveAreaActionTriggered()));
  QAction *pRemoveAllAreasAction = pContextMenu->addAction("Remove all areas", this, SLOT(clear()));
  QAction *pCreateNewAreaAction = pContextMenu->addAction("Create new area", this, SLOT(createCanvasAreaAndSetCurrent()));
  QAction *pClearAreaAction = pContextMenu->addAction("Clear area", this, SLOT(handleClearAreaActionTriggered()));
  QAction *pSaveAsAction = pContextMenu->addAction("Save as", this, SLOT(handleSaveAsActionTriggered()));

  if (tabIndex < 0 && currentIndex < 0)
    {
      pRenameAreaAction->setEnabled(false);
      pRemoveAreaAction->setEnabled(false);
      pClearAreaAction->setEnabled(false);
      pSaveAsAction->setEnabled(false);
    }
  else
  {
    if (tabIndex < 0) // Allow context menu in canvas area too
      tabIndex = currentIndex;

    pRenameAreaAction->setData(tabIndex);
    pRemoveAreaAction->setData(tabIndex);
    pClearAreaAction->setData(tabIndex);
    pSaveAsAction->setData(tabIndex);
  }

  return pContextMenu;
}

//-------------------------------------------------------------------------------------------------

bool DQMCanvasView::eventFilter(QObject *pObject, QEvent *pEvent)
{
    if(pEvent->type() == QEvent::ContextMenu)
  {
    this->showContextMenu(this->cursor().pos());
    return true;
  }

  return QObject::eventFilter(pObject, pEvent);
}

//-------------------------------------------------------------------------------------------------

void DQMCanvasView::handleRenameAreaActionTriggered()
{
  QAction *pAction = (QAction *) sender();

	if(!pAction)
    return;

  int index = pAction->data().toInt();

  m_pTabWidget->tabBar()->renameCanvasAreaFromInputDialog(index);
}

//-------------------------------------------------------------------------------------------------

void DQMCanvasView::handleRemoveAreaActionTriggered()
{
  QAction *pAction = (QAction *) sender();

	if(!pAction)
    return;

  int index = pAction->data().toInt();
  this->removeCanvasArea(index);
}

//-------------------------------------------------------------------------------------------------

void DQMCanvasView::handleClearAreaActionTriggered()
{
  QAction *pAction = (QAction *) sender();

	if(!pAction)
    return;

  int index = pAction->data().toInt();
  this->clearArea(index);
}

//-------------------------------------------------------------------------------------------------

void DQMCanvasView::handleSaveAsActionTriggered()
{
  QAction *pAction = (QAction *) sender();

	if(!pAction)
    return;

  int index = pAction->data().toInt();
  DQMCanvasArea *pCanvasArea = this->getCanvasArea(index);

	if(!pCanvasArea)
    return;

  this->getMonitoring()->getController()->saveAs(pCanvasArea);
}

}

